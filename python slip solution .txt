4/14/24, 10:41 PM slip1

In [1]: # Write a Python program to plot 2D graph of the functions f(x) = x2 and g
(x) = x3 in [−1,1]
import matplotlib.pyplot as plt
import numpy as np

def f(x):
   return x**2
def g(x):
   return x**3

x=np.linspace(-1,1,100)
y_f=f(x)
y_g=g(x)
fig,ax=plt.subplots()
ax.plot(x,y_f,label='f(x)=x^2')
ax.plot(x,y_g,label='g(x)=x^3')
ax.set_xlabel('x')
ax.set_ylabel('y')
ax.legend()
ax.set_title('2D graph of f(x)=x^2 and g(x)=x^3')
plt.show()

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip1.html?t=1713114641201 1/6



4/14/24, 10:41 PM slip1

In [8]: # Using python, represent the following information using a bar graph (in g
reen color )

# Item         clothing Food rent Petrol Misc.
# expenditure   600     4000 2000  1500  700
# (in Rs) 

import matplotlib.pyplot as plt  
left = [1,2,3,4,5] 
height = [600,4000,2000,1500,700] 
tick_label=['clothing','Food','rent','Petrol','Misc'] 
plt.bar (left,height,tick_label = tick_label,width = 0.8 ,color = ['gree
n','red']) 
plt.xlabel('Item') 
plt.ylabel('Expenditure') 
plt. show()

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip1.html?t=1713114641201 2/6



4/14/24, 10:41 PM slip1

In [4]: # Write a Python program to draw a polygon with vertices (0,0),(2,0),(2,3) 
and (1,6) and rotate
# it by 180◦

import matplotlib.pyplot as plt 
import numpy as np 
vertices = np.array([[0, 0], [2, 0], [2, 3], [1, 6],[0,0]]) 
plt.figure() 
plt.plot(vertices[:, 0], vertices[:, 1], 'red') 
plt.title('Original Polygon') 
plt.xlabel('X') 
plt.ylabel('Y') 

theta = np.pi  # 180 degrees 
rotation_matrix = np.array([[np.cos(theta), -np.sin(theta)], 
                           [np.sin(theta), np.cos(theta)]]) 
vertices_rotated = np.dot(vertices, rotation_matrix) 
plt.figure() 
plt.plot(vertices_rotated[:, 0], vertices_rotated[:, 1], 'black') 
plt.title('Rotated Polygon (180 degrees)') 
plt.xlabel('X') 
plt.ylabel('Y') 
plt.show()

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip1.html?t=1713114641201 3/6



4/14/24, 10:41 PM slip1

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip1.html?t=1713114641201 4/6



4/14/24, 10:41 PM slip1

In [13]: # Write a Python program to find the area and perimeter of the ∆ABC, where 
A[0,0],B[5,0],C[3,3].

import numpy as np 

A = np.array([0, 0]) 
B = np.array([5, 0]) 
C = np.array([3, 3]) 
# Calculate the side lengths of the triangle 
AB = np.linalg.norm(B - A) 
BC = np.linalg.norm(C - B) 
CA = np.linalg.norm(A - C) 
# Calculate the semiperimeter 
s = (AB + BC + CA) / 2 
# Calculate the area using Heron's formula 
area = np.sqrt(s * (s - AB) * (s - BC) * (s - CA)) 
# Calculate the perimeter 
perimeter = AB + BC + CA 
# Print the results 
print("Triangle ABC:") 
print("Side AB:", AB) 
print("Side BC:", BC) 
print("Side CA:", CA) 
print("Area:", area) 
print("Perimeter:", perimeter)

Triangle ABC:
Side AB: 5.0
Side BC: 3.605551275463989
Side CA: 4.242640687119285
Area: 7.5000000000000036
Perimeter: 12.848191962583275

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip1.html?t=1713114641201 5/6



4/14/24, 10:41 PM slip1

In [1]: # Write a Python program to solve the following LPP:
# Max Z = 150x + 75y
# subject to 4x + 6y ≤24
# 5x + 3y ≤15
# x ≥0,y ≥0

from pulp import * 
# Create the LP problem as a maximization problem 
problem = LpProblem("LPP", LpMaximize) 
# Define the decision variables 
x = LpVariable('x', lowBound=0, cat='Continuous') 
y = LpVariable('y', lowBound=0, cat='Continuous') 
# Define the objective function 
Z = 150 * x + 75 * y
problem += Z 
problem += 4 * x + 6 * y <= 24 
problem += 5 * x + 3 * y <= 15
# Solve the LP problem 
problem.solve() 
# Print the status of the solution 
print("Status:", LpStatus[problem.status]) 
# Print the optimal values of x and y 
print("Optimal x =", value(x)) 
print("Optimal y =", value(y)) 
# Print the optimal value of the objective function 
print("Optimal Z =", value(problem.objective))

Status: Optimal
Optimal x = 3.0
Optimal y = 0.0
Optimal Z = 450.0

In [3]: # Apply Python program in each of the following transformations on the poin
t P[3,−1]
# (I) Refection through X−axis.
# (II) Scaling in X−coordinate by factor 2.
# (III) Scaling in Y−coordinate by factor 1.5.
# (IV) Reflection through the line y = x.

import numpy as np 

P = np.array([3,-1])
reflection_x_axis = np.array([1, -1]) * P
scaling_x = np.array([2, 1]) * P  
scaling_y = np.array([1, 1.5]) * P 
reflection_line = np.array([P[1],P[0]]) 

print("Original point P:", P) 
print("Reflection through y-axis:", reflection_x_axis) 
print("Scaling in X-coordinates by factor 2:", scaling_x) 
print("Scaling in Y-coordinates by factor 1.5:", scaling_y) 
print("Reflection through the line y = x:", reflection_line)

Original point P: [ 3 -1]
Reflection through y-axis: [3 1]
Scaling in X-coordinates by factor 3: [ 6 -1]
Scaling in Y-coordinates by factor 2.5: [ 3.  -1.5]
Reflection through the line y = -x: [-1  3]

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip1.html?t=1713114641201 6/6



4/14/24, 10:41 PM slip2

In [1]: # Write a Python program to plot 2D graph of the functions f(x) = log10(x) 
and in [0,10]

import numpy as np 
import matplotlib.pyplot as plt 
x = np.linspace(1,10) 
# Compute y values using the function f(x) = log10(x) 
y = np.log10(x) 
# Plot the graph 
plt.plot(x, y) 
plt.xlabel('x') 
plt.ylabel('f(x) = log10(x)') 
plt.title('2D Graph of f(x) = log10(x)') 
plt.grid(True) 
plt.show()

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip2.html?t=1713114694182 1/5



4/14/24, 10:41 PM slip2

In [3]: # Using  python,  represent  the  following  information  using  a  bar  gr
aph  (in 
# green color) 
# Subject      Maths  Science English Marathi Hindi 
# Percentage   68       90      70     85      91 

import matplotlib.pyplot as plt  
left = [1,2,3,4,5] 
height = [68,90,70,85,91] 
tick_label=['Maths','Science','English','Marathi','Hindi'] 
plt.bar (left,height,tick_label = tick_label,width = 0.8 ,color = ['gree
n','green']) 
plt.xlabel('Item') 
plt.ylabel('Expenditure') 
plt. show()

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip2.html?t=1713114694182 2/5



4/14/24, 10:41 PM slip2

In [4]: # Using sympy declare the points A(0,2),B(5,2),C(3,0) check whether these p
oints are collinear.
# Declare the line passing through the points A and B, find the distance of 
this line from point C.

from sympy import Point, Line 
# Declare the points A, B, and C 
A = Point(0, 2) 
B = Point(5, 2) 
C = Point(3, 0) 
# Check if points A, B, and C are collinear 
collinear = Point.is_collinear(A, B, C) 
if collinear: 
   print("Points A, B, and C are collinear.") 
else: 
   print("Points A, B, and C are not collinear.") 
# Declare the line passing through points A and B 
AB_line = Line(A, B) 
# Find the distance of the line AB from point C 
distance = AB_line.distance(C) 
print("Distance of the line passing through A and B from point C: ", distan
ce)

Points A, B, and C are not collinear.
Distance of the line passing through A and B from point C:  2

In [1]: # Write a Python program to find the area and perimeter of the  ABC, where 
# A[0, 0] B[6, 0], C[4,4]. 

import numpy as np 
# Define the vertices of the triangle 
A = np.array([0, 0]) 
B = np.array([6, 0]) 
C = np.array([4, 4]) 
# Calculate the side lengths of the triangle 
AB = np.linalg.norm(B - A) 
BC = np.linalg.norm(C - B) 
CA = np.linalg.norm(A - C) 
# Calculate the semiperimeter 
s = (AB + BC + CA) / 2 
# Calculate the area using Heron's formula 
area = np.sqrt(s * (s - AB) * (s - BC) * (s - CA)) 
# Calculate the perimeter 
perimeter = AB + BC + CA 
# Print the results 
print("Triangle ABC:") 
print("Side AB:", AB) 
print("Side BC:", BC) 
print("Side CA:", CA) 
print("Area:", area) 
print("Perimeter:", perimeter)

Triangle ABC:
Side AB: 6.0
Side BC: 4.47213595499958
Side CA: 5.656854249492381
Area: 11.999999999999998
Perimeter: 16.12899020449196

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip2.html?t=1713114694182 3/5



4/14/24, 10:41 PM slip2

In [4]: # Write a Python program to solve the following LPP:
# Max Z = 5x + 3y
# subject to x + y ≤7
# 2x + 5y ≤1
# x ≥0,y ≥0

from pulp import * 
# Create the LP problem as a maximization problem 
problem = LpProblem("LPP", LpMaximize) 
# Define the decision variables 
x = LpVariable('x', lowBound=0, cat='Continuous') 
y = LpVariable('y', lowBound=0, cat='Continuous') 
# Define the objective function 
Z = 5 * x + 3 * y

problem += Z 
problem +=  x + y <= 7 
problem += 2*x +5* y <= 1 
# Solve the LP problem 
problem.solve() 
# Print the status of the solution 
print("Status:", LpStatus[problem.status]) 
# Print the optimal values of x and y 
print("Optimal x =", value(x)) 
print("Optimal y =", value(y)) 
# Print the optimal value of the objective function 
print("Optimal Z =", value(problem.objective))

Status: Optimal
Optimal x = 0.5
Optimal y = 0.0
Optimal Z = 2.5

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip2.html?t=1713114694182 4/5



4/14/24, 10:41 PM slip2

In [17]: # Apply Python program in each of the following transformations on the poin
t P[4,−2]
# (I) Refection through Y−axis.
# (II) Scaling in X−coordinate by factor 3.
# (III) Scaling in Y−coordinate by factor 2.5
# (IV) Reflection through the line y = −x.

import numpy as np 

P = np.array([4, -2]) 
# Reflection through y-axis 
reflection_y_axis = np.array([-1, 1]) * P 
# Scaling in X-coordinates by factor 3 
scaling_x = np.array([3, 1]) * P 
# Scaling in Y-coordinates by factor 2.5 
scaling_y = np.array([1, 2.5]) * P 
# Reflection through the line y = -x 
reflection_line = np.array([-P[1],-P[0]]) 
print("Original point P:", P) 
print("Reflection through y-axis:", reflection_y_axis) 
print("Scaling in X-coordinates by factor 3:", scaling_x) 
print("Scaling in Y-coordinates by factor 2.5:", scaling_y) 
print("Reflection through the line y = -x:", reflection_line)

Original point P: [ 4 -2]
Reflection through y-axis: [-4 -2]
Scaling in X-coordinates by factor 3: [12 -2]
Scaling in Y-coordinates by factor 2.5: [ 4. -5.]
Reflection through the line y = -x: [ 2 -4]

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip2.html?t=1713114694182 5/5



4/14/24, 10:42 PM slip3

In [1]: # Using Python plot the graph of function f(x) = cos(x) on the interval [0,
2π].
import numpy as np 
import matplotlib.pyplot as plt 
x = np.linspace(0,2*np.pi) 
y = np.cos(x) 
plt.plot(x, y) 
plt.xlabel('x') 
plt.ylabel('f(x) = log10(x)') 
plt.title('2D Graph of f(x) = log10(x)') 
plt.show()

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip3.html?t=1713114742434 1/5



4/14/24, 10:42 PM slip3

In [2]: # Following is the information of students participating in various games i
n a school. Represent it
# by a Bar graph with bar width of 0.7 inches.
# Game               Cricket Football Hockey Chess Tennis
# Number of students   65     30        54    10     20

import matplotlib.pyplot as plt  
left = [1,2,3,4,5] 
height = [65,30,54,10,20] 
tick_label=['Cricket','Football','Hockey','Chess','Tennis'] 
plt.bar (left,height,tick_label = tick_label,width = 0.7 ,color = ['orang
e','green']) 
plt.xlabel('Games') 
plt.ylabel('No.Of Student') 
plt. show()

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip3.html?t=1713114742434 2/5



4/14/24, 10:42 PM slip3

In [6]: # f the line with points A[2,1],B[4,−1] is transformed by the transformatio
n matrix [T] =[1 2
#                           2 1]
# then using python, find the equation of transformed line

import numpy as np 

A = np.array([2, 1]) 
B = np.array([4, -1]) 
T = np.array([[1, 2], [2, 1]]) 
A_transformed = np.dot(T, A) 
B_transformed = np.dot(T, B) 
# Extract coordinates of transformed points 
x1_transformed, y1_transformed = A_transformed 
x2_transformed, y2_transformed = B_transformed 

m_transformed = (y2_transformed - y1_transformed) / (x2_transformed - x1_tr
ansformed) 

b_transformed = y1_transformed - m_transformed * x1_transformed 
# Format the equation of the transformed line 
equation_transformed = f'y = {m_transformed} * x + {b_transformed}' 
print("Equation of transformed line: ", equation_transformed)

Equation of transformed line:  y = -1.0 * x + 9.0

In [7]: # Generate line segment having endpoints (0,0) and (10,10) find midpoint of 
line segment

x1, y1 = 0, 0 
x2, y2 = 10, 10 
# Calculate midpoint 
midpoint_x = (x1 + x2) / 2 
midpoint_y = (y1 + y2) / 2 
# Print midpoint 
print("Midpoint: ({}, {})".format(midpoint_x, midpoint_y))

Midpoint: (5.0, 5.0)

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip3.html?t=1713114742434 3/5



4/14/24, 10:42 PM slip3

In [3]: # Write a Python program to solve the following LPP:
# Min Z = 3.5x + 2y
# subject to x + y ≥5
# x ≥4
# y ≤2
# x ≥0,y ≥0

from pulp import * 

problem= LpProblem("Minimize Z", LpMinimize) 
x= LpVariable("x", lowBound=0, cat='Continuous') 
y= LpVariable("y", lowBound=0, cat='Continuous') 

Z = 3.5 * x + 2 * y 
problem+= Z 

problem+= x + y >= 5
problem+= x >= 4 
problem+= y <= 2 

problem.solve() 

print("Optimal solution:") 
print("x =", value(x)) 
print("y =", value(y)) 
print("Optimal value of Z =",value(problem.objective))

Optimal solution:
x = 4.0
y = 1.0
Optimal value of Z = 16.0

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip3.html?t=1713114742434 4/5



4/14/24, 10:42 PM slip3

In [11]: # Apply Python program in each of the following transformations on the poin
t P[4,−2]
# (I) Refection through Y−axis.
# (II) Scaling in X−coordinate by factor 3.
# (III) Scaling in Y−coordinate by factor 2.5
# (IV) Reflection through the line y = −x.

import numpy as np 

P = np.array([4, -2]) 
# Reflection through y-axis 
reflection_y_axis = np.array([-1, 1]) * P 
# Scaling in X-coordinates by factor 3 
scaling_x = np.array([3, 1]) * P 
# Scaling in Y-coordinates by factor 2.5 
scaling_y = np.array([1, 2.5]) * P 
# Reflection through the line y = -x 
reflection_line = np.array([-P[1],-P[0]]) 
print("Original point P:", P) 
print("Reflection through y-axis:", reflection_y_axis) 
print("Scaling in X-coordinates by factor 3:", scaling_x) 
print("Scaling in Y-coordinates by factor 2.5:", scaling_y) 
print("Reflection through the line y = -x:", reflection_line)

Original point P: [ 4 -2]
Reflection through y-axis: [-4 -2]
Scaling in X-coordinates by factor 3: [12 -2]
Scaling in Y-coordinates by factor 2.5: [ 4. -5.]
Reflection through the line y = -x: [ 2 -4]

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip3.html?t=1713114742434 5/5



4/14/24, 10:43 PM slip4

In [1]: # Write a Python program to plot 2D graph of the functions f(x) = log10(x)  
in the [0,10]

import numpy as np 
import matplotlib.pyplot as plt 
x = np.linspace(1,10) 
# Compute y values using the function f(x) = log10(x) 
y = np.log10(x) 
# Plot the graph 
plt.plot(x, y) 
plt.xlabel('x') 
plt.ylabel('f(x) = log10(x)') 
plt.title('2D Graph of f(x) = log10(x)') 
plt.grid(True) 
plt.show()

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip4.html?t=1713114796841 1/6



4/14/24, 10:43 PM slip4

In [2]: # Using Python plot the graph of function f(x) = sin−1(x) on the interval 
[−1,1]
import numpy as np 
import matplotlib.pyplot as plt 
x = np.linspace(-1,1) 
y = 1/np.sin(x) 
# Plot the graph 
plt.plot(x, y) 
plt.xlabel('x') 
plt.ylabel('f(x) = sin-1(X)') 
plt.title('2D Graph of f(x) = log10(x)') 
plt.grid(True) 
plt.show()

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip4.html?t=1713114796841 2/6



4/14/24, 10:43 PM slip4

In [3]: # if the line with points A[3,1],B[5,−1] is transformed by the transformati
on matrix [T] =[3 −2
#                           2 1]
# then using python, find the equation of transformed line.

import numpy as np 

A = np.array([3, 1]) 
B = np.array([5, -1]) 
T = np.array([[3, -2], [2, 1]]) 
A_transformed = np.dot(T, A) 
B_transformed = np.dot(T, B) 
# Extract coordinates of transformed points 
x1_transformed, y1_transformed = A_transformed 
x2_transformed, y2_transformed = B_transformed 

m_transformed = (y2_transformed - y1_transformed) / (x2_transformed - x1_tr
ansformed) 

b_transformed = y1_transformed - m_transformed * x1_transformed 
# Format the equation of the transformed line 
equation_transformed = f'y = {m_transformed} * x + {b_transformed}' 
print("Equation of transformed line: ", equation_transformed)

Equation of transformed line:  y = 0.2 * x + 5.6

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip4.html?t=1713114796841 3/6



4/14/24, 10:43 PM slip4

In [2]: # Using python, generate line passing through points (2,3) and (4,3) and fi
nd equation of the line
import matplotlib.pyplot as plt 
import numpy as np 
# Define the points 
x = np.array([2, 4]) 
y = np.array([3, 3]) 
# Calculate the slope (m) and y-intercept (b) of the line 
m = (y[1] - y[0]) / (x[1] - x[0]) 
b = y[0] - m * x[0] 
# Print the equation of the line 
print(f"The equation of the line is: y = {m : .2f}x + {b:.2f}") 
# Plot the points and the line 
plt.scatter(x, y, c='blue', label='Points') 
plt.plot(x, m * x + b, c='red', label='Line') 
plt.xlabel('X') 
plt.ylabel('Y') 
plt.title('Line Passing through Points') 
plt.legend() 
plt.show()

The equation of the line is: y =  0.00x + 3.00

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip4.html?t=1713114796841 4/6



4/14/24, 10:43 PM slip4

In [4]: # Write a Python program to solve the following LPP:
# Max Z = 150x + 75y
# subject to 4x + 6y ≤24
#            5x + 3y ≤15
#            x ≥0,y ≥0.

from pulp import * 
# Create the LP problem as a maximization problem 
problem = LpProblem("LPP", LpMaximize) 
# Define the decision variables 
x = LpVariable('x', lowBound=0, cat='Continuous') 
y = LpVariable('y', lowBound=0, cat='Continuous') 
# Define the objective function 
Z=150 * x + 75 * y
problem += Z 
# Define the constraints 
problem += 4 * x + 6 * y <= 24  
problem += 5 * x + 3 * y <= 15  
# Solve the LP problem 
problem.solve() 
# Print the status of the solution 
print("Status:", LpStatus[problem.status]) 
# Print the optimal values of x and y 
print("Optimal x =", value(x)) 
print("Optimal y =", value(y)) 
# Print the optimal value of the objective function 
print("Optimal Z =", value(problem.objective))

Status: Optimal
Optimal x = 3.0
Optimal y = 0.0
Optimal Z = 450.0

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip4.html?t=1713114796841 5/6



4/14/24, 10:43 PM slip4

In [4]: # Find the combined transformation of the line segment between the points A
[4,−1] & B[3,0]
# by using Python program for the following sequence of transformations:-
# (I) Shearing in X direction by 9 units.
# (II) Rotation about origin through an angle π.
# (III) Scaling in X− coordinate by 2 units.
# (IV) Reflection through the line y = x.

import numpy as np 
# Input points A and B 
A = np.array([4, -1]) 
B = np.array([3, 0]) 
# Transformation 1: Shearing in X-Direction by 9 units 
shear_matrix = np.array([[1, 9], 
                       [0, 1]]) 
A_sheared = np.dot(shear_matrix, A) 
B_sheared = np.dot(shear_matrix, B) 
print("Transformed Point A after Shearing:", A_sheared) 
print("Transformed Point B after Shearing:", B_sheared)

# Transformation 2: Rotation about origin through an angle of pi (180 degre
es) 
rotation_matrix = np.array([[np.cos(np.pi), -np.sin(np.pi)], 
                          [np.sin(np.pi), np.cos(np.pi)]]) 
A_rotated = np.dot(rotation_matrix, A_sheared) 
B_rotated = np.dot(rotation_matrix, B_sheared) 
print("Transformed Point A after Rotation:", A_rotated) 
print("Transformed Point B after Rotation:", B_rotated) 
# Transformation 3: Scaling in X-Coordinate by 2 units 
scaling_matrix = np.array([[2, 0], 
                         [0, 1]]) 
A_scaled = np.dot(scaling_matrix, A_rotated) 
B_scaled = np.dot(scaling_matrix, B_rotated) 
print("Transformed Point A after Scaling:", A_scaled) 
print("Transformed Point B after Scaling:", B_scaled) 
# Transformation 4: Reflection through the line y = x 
reflection_matrix = np.array([[0, 1], 
                            [1, 0]]) 
A_reflected = np.dot(reflection_matrix, A_scaled) 
B_reflected = np.dot(reflection_matrix, B_scaled) 
print("Transformed Point A after Reflection:", A_reflected) 
print("Transformed Point B after Reflection:", B_reflected)

Transformed Point A after Shearing: [-5 -1]
Transformed Point B after Shearing: [3 0]
Transformed Point A after Rotation: [5. 1.]
Transformed Point B after Rotation: [-3.0000000e+00  3.6739404e-16]
Transformed Point A after Scaling: [10.  1.]
Transformed Point B after Scaling: [-6.0000000e+00  3.6739404e-16]
Transformed Point A after Reflection: [ 1. 10.]
Transformed Point B after Reflection: [ 3.6739404e-16 -6.0000000e+00]

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip4.html?t=1713114796841 6/6



4/14/24, 10:44 PM slip5

In [1]: # Using Python plot the surface plot of function z = cos (x2 + y2 −0.5)in t
he interval from −1 < x,y < 1

import numpy as np 
import matplotlib.pyplot as plt 
from mpl_toolkits.mplot3d import Axes3D 

def func(x, y): 
   return np.cos(x**2 + y**2 - 0.5) 
# Generate x, y values in the interval from -1 to 1 
x = np.linspace(-1, 1, 100) 
y = np.linspace(-1, 1, 100) 
X, Y = np.meshgrid(x, y)  # Create a grid of x, y values 
Z = func(X, Y)  # Compute z values using the function 
# Create a 3D plot 
fig = plt.figure() 
ax = fig.add_subplot(111, projection='3d') 
ax.plot_surface(X, Y, Z, cmap='viridis')  # Plot the surface 
ax.set_xlabel('X') 
ax.set_ylabel('Y') 
ax.set_zlabel('Z') 
ax.set_title('Surface Plot of z = cos(x**2 + y**2 - 0.5)') 
plt.show()  # Show the plot

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip5.html?t=1713114852511 1/6



4/14/24, 10:44 PM slip5

In [2]: # Generate 3D surface Plot for the function f(x) = sin (x2 + y2)in the inte
rval [0,10]

import numpy as np 
import matplotlib.pyplot as plt 
from mpl_toolkits.mplot3d import Axes3D 
# Define the function 
def func(x, y): 
   return np.sin(x**2 + y**2) 
# Generate x, y values in the interval from 0 to 10 
x = np.linspace(0, 10, 100) 
y = np.linspace(0, 10, 100) 
X, Y = np.meshgrid(x, y)  # Create a grid of x, y values 
Z = func(X, Y)  # Compute z values using the function 
# Create a 3D plot 
fig = plt.figure() 
ax = fig.add_subplot(111, projection='3d') 
ax.plot_surface(X, Y, Z, cmap='viridis')  # Plot the surface 
ax.set_xlabel('X') 
ax.set_ylabel('Y') 
ax.set_zlabel('Z') 
ax.set_title('Surface Plot of f(x) = sin(x**2 + y**2)') 
plt.show()  # Show the plo

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip5.html?t=1713114852511 2/6



4/14/24, 10:44 PM slip5

In [9]: # Using python, generate triangle with vertices (0,0),(4,0),(4,3) check whe
ther the triangle is Right angle triangle

import matplotlib.pyplot as plt 
# Define the vertices of the triangle 
vertex1 = (0, 0) 
vertex2 = (4, 0) 
vertex3 = (4, 3) 
# Extract x and y coordinates of the vertices 
x = [vertex1[0], vertex2[0], vertex3[0], vertex1[0]] 
y = [vertex1[1], vertex2[1], vertex3[1], vertex1[1]] 
# Plot the triangle 
plt.plot(x, y, 'black', label='Triangle') 
plt.plot(vertex1[0], vertex1[1], 'ro', label='Vertex 1') 
plt.plot(vertex2[0], vertex2[1], 'go', label='Vertex 2') 
plt.plot(vertex3[0], vertex3[1], 'mo', label='Vertex 3') 
plt.xlabel('X') 
plt.ylabel('Y') 
plt.title('Triangle with Vertices') 
plt.legend() 
plt.grid(True) 
plt.show()

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip5.html?t=1713114852511 3/6



4/14/24, 10:44 PM slip5

In [10]: # Write a Python program to find the area and perimeter of the ∆ABC, where 
A[0,0],B[6,0],C[4,4]

import numpy as np 
# Define the vertices of the triangle 
A = np.array([0, 0]) 
B = np.array([6, 0]) 
C = np.array([4, 4]) 
# Calculate the side lengths of the triangle 
AB = np.linalg.norm(B - A) 
BC = np.linalg.norm(C - B) 
CA = np.linalg.norm(A - C) 
# Calculate the semiperimeter 
s = (AB + BC + CA) / 2 
# Calculate the area using Heron's formula 
area = np.sqrt(s * (s - AB) * (s - BC) * (s - CA)) 
# Calculate the perimeter 
perimeter = AB + BC + CA 
# Print the results 
print("Triangle ABC:") 
print("Side AB:", AB) 
print("Side BC:", BC) 
print("Side CA:", CA) 
print("Area:", area) 
print("Perimeter:", perimeter)

Triangle ABC:
Side AB: 6.0
Side BC: 4.47213595499958
Side CA: 5.656854249492381
Area: 11.999999999999998
Perimeter: 16.12899020449196

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip5.html?t=1713114852511 4/6



4/14/24, 10:44 PM slip5

In [11]: # Write a Python program to solve the following LPP:
# Max Z = 5x + 3y
# subject to x + y ≤7
# 2x + 5y ≤1
# x ≥0,y ≥0

from pulp import * 
# Create the LP problem as a maximization problem 
problem = LpProblem("LPP", LpMaximize) 
# Define the decision variables 
x = LpVariable('x', lowBound=0, cat='Continuous') 
y = LpVariable('y', lowBound=0, cat='Continuous') 
# Define the objective function 
Z=5 * x + 3 * y
problem += Z 
# Define the constraints 
problem +=  x +  y <= 7 
problem += 2 * x + 5 * y <= 1  
# Solve the LP problem 
problem.solve() 
# Print the status of the solution 
print("Status:", LpStatus[problem.status]) 
# Print the optimal values of x and y 
print("Optimal x =", value(x)) 
print("Optimal y =", value(y)) 
# Print the optimal value of the objective function 
print("Optimal Z =", value(problem.objective))

Status: Optimal
Optimal x = 0.5
Optimal y = 0.0
Optimal Z = 2.5

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip5.html?t=1713114852511 5/6



4/14/24, 10:44 PM slip5

In [14]: # Apply Python program in each of the following transformations on the poin
t P[3,8]
# (I) Refection through X−axis.
# (II) Scaling in X−coordinate by factor 6.
# (III) Rotation about origin through an angle 30◦.
# (IV) Reflection through the line y = −x.

import numpy as np

P=np.array([3,8])
# (I) Refection through X−axis.
reflection_x_axis = np.array([1, -1]) * P
# Scaling in X−coordinate by factor 6.
scaling_x = np.array([6, 1]) * P
# Rotation about origin through an angle 30◦.
rotation_matrix = np.array([[np.cos(np.pi/6), -np.sin(np.pi/6)], 
                           [np.sin(np.pi/6), np.cos(np.pi/6)]]) 
P_rotation = np.dot(rotation_matrix, P)
# Reflection through the line y = -x 
reflection_line = np.array([-P[1],-P[0]]) 

print("Original point P:", P) 
print("Reflection through y-axis:", reflection_x_axis) 
print("Scaling in X-coordinates by factor 6:", scaling_x) 
print("Rotation about origin through an angle of 30 degree:",P_rotation)
print("Reflection through the line y = -x:", reflection_line)

Original point P: [3 8]
Reflection through y-axis: [ 3 -8]
Scaling in X-coordinates by factor 6: [18  8]
Rotation about origin through an angle of 30 degree: [-1.40192379  8.428203
23]
Reflection through the line y = -x: [-8 -3]

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip5.html?t=1713114852511 6/6



4/14/24, 10:45 PM slip6

In [1]: # Using python, generate 3D surface Plot for the function f(x) = sin (x2 + 
y2)in the interval [0,10]

import numpy as np 
import matplotlib.pyplot as plt 
from mpl_toolkits.mplot3d import Axes3D 
# Define the function 
def func(x, y): 
   return np.sin(x**2 + y**2) 
# Generate x, y values in the interval from 0 to 10 
x = np.linspace(0, 10, 100) 
y = np.linspace(0, 10, 100) 
X, Y = np.meshgrid(x, y)  # Create a grid of x, y values 
Z = func(X, Y)  # Compute z values using the function 
# Create a 3D plot 
fig = plt.figure() 
ax = fig.add_subplot(111, projection='3d') 
ax.plot_surface(X, Y, Z)  # Plot the surface 
ax.set_xlabel('X') 
ax.set_ylabel('Y') 
ax.set_zlabel('Z') 
ax.set_title('Surface Plot of f(x) = sin(x**2 + y**2)') 
plt.show()

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip6.html?t=1713114923764 1/7



4/14/24, 10:45 PM slip6

In [4]: # Draw the horizontal bar graph for the following data in Maroon colour.
# City              Pune Mumbai Nasik Nagpur Thane
# Air Quality Index 168   190   170   178     195

import matplotlib.pyplot as plt 
# Data 
left = [1, 2, 3, 4, 5] 
height = [168, 190, 170, 178, 195] 
tick_label = ['Pune', 'Mumbai', 'Nasik', 'Nagpur', 'Thane'] 
# Create a horizontal bar graph 
plt.barh(left, height, tick_label=tick_label, color='red') 
# Set labels and title 
plt.xlabel('Air Quality Index') 
plt.ylabel('City') 
plt.title('Air Quality Index by City (Horizontal Bar Graph)') 
# Show the plot 
plt.show()

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip6.html?t=1713114923764 2/7



4/14/24, 10:45 PM slip6

In [5]: # using python, rotate the line segment by 180◦ having end points (1,0) and 
(2,−1).
import numpy as np 
import matplotlib.pyplot as plt 
# Define the original line segment 
x1, y1 = 1, 0 
x2, y2 = 2, -1 
# Plot the original line segment 
plt.plot([x1, x2], [y1, y2], 'bo-', label='Original Line') 
# Compute the rotated coordinates 
x1_rot, y1_rot = -x1, -y1 
x2_rot, y2_rot = -x2, -y2 
# Plot the rotated line segment 
plt.plot([x1_rot, x2_rot], [y1_rot, y2_rot], 'ro-', label='Rotated Line') 
# Set axis limits 
plt.xlim(-3, 3) 
plt.ylim(-3, 3) 
# Add labels and title 
plt.xlabel('X') 
plt.ylabel('Y') 
plt.title('Rotation of Line Segment by 180 degrees') 
# Add legend 
plt.legend() 
# Show the plot 
plt.show()

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip6.html?t=1713114923764 3/7



4/14/24, 10:45 PM slip6

In [13]: # Write a Python program to draw a polygon with vertices (0,0),(2,0),(2,3) 
and (1,6) and rotate it by 180◦

import numpy as np
import matplotlib.pyplot as plt

# Define the vertices of the polygon
vertices = np.array([[0, 0], [2, 0], [2, 3], [1, 6],[0,0]])

# Plot the original polygon
plt.figure()
plt.plot(vertices[:, 0], vertices[:, 1], 'red') 
plt.title('Original Polygon')
plt.xlabel('X') 
plt.ylabel('Y')

# Rotate the polygon by 180 degrees

rotation_matrix = np.array([[np.cos(np.pi), -np.sin(np.pi)], [np.sin(np.p
i), np.cos(np.pi)]])
rotated_vertices = np.dot(vertices, rotation_matrix)

# Plot the rotated polygon
plt.figure()
plt.plot(rotated_vertices[:, 0], rotated_vertices[:, 1], 'black')
plt.title('Rotated Polygon (180 degrees)')
plt.xlabel('X') 
plt.ylabel('Y')
plt.show()

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip6.html?t=1713114923764 4/7



4/14/24, 10:45 PM slip6

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip6.html?t=1713114923764 5/7



4/14/24, 10:45 PM slip6

In [14]: # Write a Python program to solve the following LPP:
# Max Z = x + y
# subject to 2x −2y ≥1
# x + y ≥2
# x ≥0,y ≥0

from pulp import * 
# Create the LP problem as a maximization problem 
problem = LpProblem("LPP", LpMaximize) 
# Define the decision variables 
x = LpVariable('x', lowBound=0, cat='Continuous') 
y = LpVariable('y', lowBound=0, cat='Continuous') 
# Define the objective function 
Z= x + y
problem += Z 
# Define the constraints 
problem +=  2*x - 2*y >= 1
problem +=  x +  y >= 2 
# Solve the LP problem 
problem.solve() 
# Print the status of the solution 
print("Status:", LpStatus[problem.status]) 
# Print the optimal values of x and y 
print("Optimal x =", value(x)) 
print("Optimal y =", value(y)) 
# Print the optimal value of the objective function 
print("Optimal Z =", value(problem.objective))

Status: Unbounded
Optimal x = 0.0
Optimal y = 0.0
Optimal Z = 0.0

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip6.html?t=1713114923764 6/7



4/14/24, 10:45 PM slip6

In [1]: # Apply Python program in each of the following transformations on the poin
t P[4,−2]
# (I) Refection through Y−axis.
# (II) Scaling in X−coordinate by factor 7.
# (III) Shearing in Y direction by 3 units
# (IV) Reflection through the line y = −x.
import numpy as np
P = [4, -2]  
# Reflection through y-axis 
reflection_y_axis = np.array([-1, 1]) * P
# Scaling in X-coordinates by factor 7 
scaling_x = np.array([7, 1]) * P 
# Shearing in Y-direction by 3 units 

shearing_y = [P[0], P[1] + (3 * P[0])]

# Reflection through the line y = -x 
reflection_line = np.array([-P[1],-P[0]]) 

print("Original point P:", P) 
print("Reflection through y-axis:", reflection_y_axis) 
print("Scaling in X-coordinates by factor 7:", scaling_x) 
print("Shearing in Y-direction by 3 units: ",shearing_y) 
print("Reflection through the line y = -x:", reflection_line)

Original point P: [4, -2]
Reflection through y-axis: [-4 -2]
Scaling in X-coordinates by factor 7: [28 -2]
Shearing in Y-direction by 3 units:  [4, 10]
Reflection through the line y = -x: [ 2 -4]

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip6.html?t=1713114923764 7/7



4/14/24, 10:47 PM slip7

In [4]: # Plot the graph of f(x) = x4 in [0,5] with red dashed line with circle mar
kers.

import numpy as np 
import matplotlib.pyplot as plt 
# Define the function f(x) = x**4 
def f(x): 
   return x**4 
# Generate x values in the interval [0, 5] 
x = np.linspace(0, 5,100) 
# Generate y values using the function f(x) 
y = f(x) 
# Plot the graph with red dashed line and circle markers 
plt.plot(x, y, 'r--o', markersize=6) 

plt.xlabel('x') 
plt.ylabel('f(x)') 
plt.title('Graph of f(x) = x**4') 
plt.show()

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip7.html?t=1713115006962 1/6



4/14/24, 10:47 PM slip7

In [6]: # Using python, generate 3D surface Plot for the function f(x) = sin (x2 + 
y2)in the interval [0,10].
# also in slip 6 q1

import numpy as np 
import matplotlib.pyplot as plt 
from mpl_toolkits.mplot3d import Axes3D 
# Define the function 
def func(x, y): 
   return np.sin(x**2 + y**2) 
# Generate x, y values in the interval from 0 to 10 
x = np.linspace(0, 10, 100) 
y = np.linspace(0, 10, 100) 
X, Y = np.meshgrid(x, y)  # Create a grid of x, y values 
Z = func(X, Y)  # Compute z values using the function 
# Create a 3D plot 
fig = plt.figure() 
ax = fig.add_subplot(111, projection='3d') 
ax.plot_surface(X, Y, Z)  # Plot the surface 
ax.set_xlabel('X') 
ax.set_ylabel('Y') 
ax.set_zlabel('Z') 
ax.set_title('Surface Plot of f(x) = sin(x**2 + y**2)') 
plt.show()

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip7.html?t=1713115006962 2/6



4/14/24, 10:47 PM slip7

In [9]: # Write a Python program to reflect the line segment joining the points A
[5,3] & B[1,4] through the line y = x + 1

import matplotlib.pyplot as plt 
import numpy as np 

A = np.array([5, 3]) 
B = np.array([1, 4]) 
# Define the equation of the reflection line 
reflection_line = lambda x: x + 1 
# Plot the original line segment AB 
plt.plot([A[0], B[0]], [A[1], B[1]], '-o', label='Original Line Segment A
B') 
# Plot the reflection line 
x_vals = np.linspace(-5, 5, 100) # Generate x values for the plot 
plt.plot(x_vals, reflection_line(x_vals), '-r', label='Reflection Line y = 
x + 1') 
# Calculate the reflected points 
reflected_A = np.array([reflection_line(A[0]),  A[0]]) 
reflected_B = np.array([reflection_line(B[0]),  B[0]]) 
# Plot the reflected line segment A'B' 
plt.plot([reflected_A[0],  reflected_B[0]],  [reflected_A[1],  reflected_B
[1]],  '-o', label='Reflected Line Segment A\'B\'') 

plt.xlabel('x') 
plt.ylabel('y') 
plt.title('Line Segment Reflection') 
plt.legend()  
plt.show()

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip7.html?t=1713115006962 3/6



4/14/24, 10:47 PM slip7

In [10]: # Using sympy declare the points P(5,2),Q(5,−2),R(5,0), check whether these 
points are collinear.
# Declare the ray passing through the points P and Q, find the length of th
is ray between P and Q.Also find slope of this ray.

from sympy import Point, Line 

P = Point(5, 2) 
Q = Point(5, -2) 
R = Point(5, 0) 
# Check if points P, Q, and R are collinear 
line_PQ = Line(P, Q) 
line_PR = Line(P, R) 
collinear = line_PQ.is_parallel(line_PR) 
# Print the result 
if collinear: 
   print("Points P, Q, and R are collinear") 
else: 
   print("Points P, Q, and R are not collinear") 
# Calculate the length of the ray PQ 
length_PQ = P.distance(Q) 
# Calculate the slope of the ray PQ 
slope_PQ = (Q.y - P.y) / (Q.x - P.x) 
# Print the length and slope of the ray PQ 
print("Length of the ray PQ:", length_PQ) 
print("Slope of the ray PQ:", slope_PQ)

Points P, Q, and R are collinear
Length of the ray PQ: 4
Slope of the ray PQ: zoo

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip7.html?t=1713115006962 4/6



4/14/24, 10:47 PM slip7

In [13]: # Write a Python program to solve the following LPP:
# Min Z = 3.5x + 2y
# subject to x + y ≥5
#            x ≥4
#            y ≤2
# x ≥0,y ≥0

from pulp import * 

problem= LpProblem("Minimize Z", LpMinimize) 
x= LpVariable("x", lowBound=0, cat='Continuous') 
y= LpVariable("y", lowBound=0, cat='Continuous') 

Z = 3.5 * x + 2 * y 
problem+= Z 

problem+= x + y >= 5
problem+= x >= 4 
problem+= y <= 2 

problem.solve()

print("Status:", LpStatus[problem.status])  
print("x =", value(x)) 
print("y =", value(y)) 
print("Optimal value of Z =",value(problem.objective))

Status: Optimal
x = 4.0
y = 1.0
Optimal value of Z = 16.0

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip7.html?t=1713115006962 5/6



4/14/24, 10:47 PM slip7

In [1]: # Apply Python program in each of the following transformations on the poin
t P[4,−2]
# (I) Refection through Y−axis.
# (II) Scaling in X−coordinate by factor 5.
# (III) Rotation about origin through an angle π/2 .
# (IV) Shearing in X direction by 7 / 2 units

import numpy as np
P=np.array([4,-2])
# (I) Refection through Y−axis.
reflection_y_axis = np.array([-1, 1]) * P 
# (II) Scaling in X−coordinate by factor 5.
scaling_x = np.array([5, 1]) * P
# (III) Rotation about origin through an angle π/2 .
rotation_matrix = np.array([[np.cos(np.pi/2), -np.sin(np.pi/2)], 
                          [np.sin(np.pi/2), np.cos(np.pi/2)]]) 
P_rotation = np.dot(rotation_matrix, P)
# (IV) Shearing in X direction by 7 / 2 units
shearing_x = [P[0]+((7/2)*P[1]),P[1]] 

print("Original point P:", P) 
print("Reflection through y-axis:", reflection_y_axis) 
print("Scaling in X-coordinates by factor 3:", scaling_x) 
print("Rotation about origin through an angle of 30 degree:",P_rotation)
print("Shearing in x-direction by 7/2 units: ",shearing_x)

Original point P: [ 4 -2]
Reflection through y-axis: [-4 -2]
Scaling in X-coordinates by factor 3: [20 -2]
Rotation about origin through an angle of 30 degree: [2. 4.]
Shearing in x-direction by 7/2 units:  [-3.0, -2]

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip7.html?t=1713115006962 6/6



4/14/24, 10:47 PM slip8

In [1]: # Using Python plot the graph of function f(x) = cos(x) in the interval [0,
2π].

import numpy as np 
import matplotlib.pyplot as plt 
# Generate x values 
x = np.linspace(0, 2 * np.pi, 500) 
y = np.cos(x) 
plt.plot(x, y) 

plt.xlabel('x') 
plt.ylabel('f(x) = cos(x)') 
plt.title('Graph of f(x) = cos(x)') 
plt.grid(True) 
plt.show()

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip8.html?t=1713115049842 1/6



4/14/24, 10:47 PM slip8

In [4]: # Write a Python program to generate 3D plot of the functions z = sin x+ co
s y in −10 < x,y < 10
import numpy as np 
import matplotlib.pyplot as plt 
from mpl_toolkits.mplot3d import Axes3D 

x = np.linspace(-10, 10, 100) 
y = np.linspace(-10, 10, 100) 
 
X, Y = np.meshgrid(x, y) 
# Compute z values for the function z = sin(x) + cos(y) 
Z = np.sin(X) + np.cos(Y) 
# Create a 3D plot 
fig = plt.figure() 
ax = fig.add_subplot(111, projection='3d') 
ax.plot_surface(X, Y, Z) 
ax.set_xlabel('x') 
ax.set_ylabel('y') 
ax.set_zlabel('z') 
ax.set_title('3D Plot of z = sin(x) + cos(y)') 
plt.show()

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip8.html?t=1713115049842 2/6



4/14/24, 10:47 PM slip8

In [9]: # Using python, generate triangle with vertices (0,0),(4,0),(1,4), check wh
ether the triangle isScalene triangle

import matplotlib.pyplot as plt 
# Vertices of the triangle 
vertex1 = (0, 0) 
vertex2 = (4, 0) 
vertex3 = (1, 4) 
# Plot the triangle 
plt.plot(*zip(vertex1, vertex2, vertex3, vertex1), marker='o') 
plt.xlabel('X') 
plt.ylabel('Y') 
plt.title('Triangle') 
plt.grid(True) 
plt.show()

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip8.html?t=1713115049842 3/6



4/14/24, 10:47 PM slip8

In [10]: # Write a Python program to find the area and perimeter of the ∆ABC, where 
A[0,0],B[6,0],C[4,4]

import numpy as np 
# Define the vertices of the triangle 
A = np.array([0, 0]) 
B = np.array([6, 0]) 
C = np.array([4, 4]) 
# Calculate the side lengths of the triangle 
AB = np.linalg.norm(B - A) 
BC = np.linalg.norm(C - B) 
CA = np.linalg.norm(A - C) 
# Calculate the semiperimeter 
s = (AB + BC + CA) / 2 
# Calculate the area using Heron's formula 
area = np.sqrt(s * (s - AB) * (s - BC) * (s - CA)) 
# Calculate the perimeter 
perimeter = AB + BC + CA 
# Print the results 
print("Triangle ABC:") 
print("Side AB:", AB) 
print("Side BC:", BC) 
print("Side CA:", CA) 
print("Area:", area) 
print("Perimeter:", perimeter)

Triangle ABC:
Side AB: 6.0
Side BC: 4.47213595499958
Side CA: 5.656854249492381
Area: 11.999999999999998
Perimeter: 16.12899020449196

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip8.html?t=1713115049842 4/6



4/14/24, 10:47 PM slip8

In [15]: # Write a Python program to solve the following LPP:
# Max Z = 150x + 75y
# subject to 4x + 6y ≤24
# 5x + 3y ≤15
# x ≥0,y ≥0

from pulp import * 
# Create the LP problem as a maximization problem 
problem = LpProblem("LPP", LpMaximize) 
# Define the decision variables 
x = LpVariable('x', lowBound=0, cat='Continuous') 
y = LpVariable('y', lowBound=0, cat='Continuous') 
# Define the objective function 
Z= 150*x + 75*y
problem += Z 
# Define the constraints 
problem +=  4*x + 6*y <=24
problem +=  5*x +  3*y <=15
# Solve the LP problem 
problem.solve() 
# Print the status of the solution 
print("Status:", LpStatus[problem.status]) 
# Print the optimal values of x and y 
print("Optimal x =", value(x)) 
print("Optimal y =", value(y)) 
# Print the optimal value of the objective function 
print("Optimal Z =", value(problem.objective))

Status: Optimal
Optimal x = 3.0
Optimal y = 0.0
Optimal Z = 450.0

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip8.html?t=1713115049842 5/6



4/14/24, 10:47 PM slip8

In [16]: # Apply Python program in each of the following transformations on the poin
t P[4,−2]
# (I) Refection through Y−axis.
# (II) Scaling in X−coordinate by factor 3.
# (III) Rotation about origin through an angle π.
# (IV) Shearing in both X and Y direction by −2 and 4 units respectively

import numpy as np
P=np.array([4,-2])
# (I) Refection through Y−axis.
reflection_y_axis = np.array([-1, 1]) * P 
# (II) Scaling in X−coordinate by factor 3.
scaling_x = np.array([3, 1]) * P
# (III) Rotation about origin through an angle π .
rotation_matrix = np.array([[np.cos(np.pi), -np.sin(np.pi)], 
                          [np.sin(np.pi), np.cos(np.pi)]]) 
P_rotation = np.dot(rotation_matrix, P)
# (IV) Shearing in both X and Y direction by −2 and 4 units 
P_sheared = np.array([P[0] + (-2 * P[1]), P[1] + (4 * P[0])])

print("Original point P:", P) 
print("Reflection through y-axis:", reflection_y_axis) 
print("Scaling in X-coordinates by factor 3:", scaling_x)
print("Rotation about origin through an angle of 180 degree:",P_rotation)
print(" Shearing in both X and Y direction by -2 and 4 units respectivel
y:")
print("Shearing in both X and Y direction by −2 and 4 units:",P_sheared)

Original point P: [ 4 -2]
Reflection through y-axis: [-4 -2]
Scaling in X-coordinates by factor 3: [12 -2]
Rotation about origin through an angle of 180 degree: [-4.  2.]
Shearing in both X and Y direction by -2 and 4 units respectively:

Shearing in X direction: [8, -2]
Shearing in Y direction: [4, 14]

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip8.html?t=1713115049842 6/6



4/14/24, 10:48 PM slip9

In [1]: # Write a python program to Plot 2D X-axis and Y-axis black color and in th
e same diagram plot green triangle with vertices [5,4],[7,4],[6,6].

import matplotlib.pyplot as plt 
triangle_vertices = [[5, 4], [7, 4], [6, 6]] 

x = [vertex[0] for vertex in triangle_vertices] 
y = [vertex[1] for vertex in triangle_vertices] 
# Plot the X-axis and Y-axis in black color 
plt.axhline(0, color='black') 
plt.axvline(0, color='black') 
# Plot the triangle with green color 
plt.plot(x + [x[0]], y + [y[0]], 'g') 
# Set the plot limits and labels 
plt.xlim(4, 8) 
plt.ylim(3, 7) 
plt.xlabel('X-axis') 
plt.ylabel('Y-axis') 
# Show the plot 
plt.show()

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip9.html?t=1713115110640 1/5



4/14/24, 10:48 PM slip9

In [5]: # Using Python plot the graph of function f(x) = cos(x) on the interval [0,
2π].

import numpy as np 
import matplotlib.pyplot as plt 
# Generate x values 
x = np.linspace(0, 2 * np.pi, 500) 
y = np.cos(x) 
plt.plot(x, y) 

plt.xlabel('x') 
plt.ylabel('f(x) = cos(x)') 
plt.title('Graph of f(x) = cos(x)') 
plt.grid(True) 
plt.show()

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip9.html?t=1713115110640 2/5



4/14/24, 10:48 PM slip9

In [6]: # Using sympy, declare the points A(0,7),B(5,2). Declare the line segment p
assing through them.
# Find the length and midpoint of the line segment passing through points A 
and B

from sympy import Point, Line 

A = Point(0, 7) 
B = Point(5, 2) 
# Declare the line passing through points A and B 
line_AB = Line(A, B) 
# Calculate the length of the line segment AB 
length_AB = A.distance(B) 
# Calculate the midpoint of the line segment AB 
midpoint_AB = ((A[0] + B[0]) / 2, (A[1] + B[1]) / 2) 
# Print the results 
print("Point A: {}".format(A)) 
print("Point B: {}".format(B)) 
print("Line segment AB: {}".format(line_AB)) 
print("Length of line segment AB: {}".format(length_AB)) 
print("Midpoint of line segment AB: {}".format(midpoint_AB))

Point A: Point2D(0, 7)
Point B: Point2D(5, 2)
Line segment AB: Line2D(Point2D(0, 7), Point2D(5, 2))
Length of line segment AB: 5*sqrt(2)
Midpoint of line segment AB: (5/2, 9/2)

In [7]: # Write a python program to find the area and perimeter of ∆ABC where A(0,
0),B(5,0),C(3,3)

import numpy as np 

A = np.array([0, 0]) 
B = np.array([5, 0]) 
C = np.array([3, 3]) 

AB = np.linalg.norm(B - A) 
BC = np.linalg.norm(C - B) 
CA = np.linalg.norm(A - C) 

s = (AB + BC + CA) / 2 
area = np.sqrt(s * (s - AB) * (s - BC) * (s - CA)) 
perimeter = AB + BC + CA 

print("Triangle ABC:") 
print("Side AB:", AB) 
print("Side BC:", BC) 
print("Side CA:", CA) 
print("Area:", area) 
print("Perimeter:", perimeter)

Triangle ABC:
Side AB: 5.0
Side BC: 3.605551275463989
Side CA: 4.242640687119285
Area: 7.5000000000000036
Perimeter: 12.848191962583275

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip9.html?t=1713115110640 3/5



4/14/24, 10:48 PM slip9

In [8]: # Write a Python program to solve the following LPP:
#     Max Z  = 150x + 75y
# subject to 4x + 6y ≤24
#            5x + 3y ≤15
# x ≥0,y ≥0

from pulp import * 
# Create the LP problem as a maximization problem 
problem = LpProblem("LPP", LpMaximize) 
# Define the decision variables 
x = LpVariable('x', lowBound=0, cat='Continuous') 
y = LpVariable('y', lowBound=0, cat='Continuous') 
# Define the objective function 
Z= 150*x + 75*y
problem += Z 
# Define the constraints 
problem +=  4*x + 6*y <=24
problem +=  5*x +  3*y <=15
# Solve the LP problem 
problem.solve() 
# Print the status of the solution 
print("Status:", LpStatus[problem.status]) 
# Print the optimal values of x and y 
print("Optimal x =", value(x)) 
print("Optimal y =", value(y)) 
# Print the optimal value of the objective function 
print("Optimal Z =", value(problem.objective))

Status: Optimal
Optimal x = 3.0
Optimal y = 0.0
Optimal Z = 450.0

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip9.html?t=1713115110640 4/5



4/14/24, 10:48 PM slip9

In [10]: # Write a python program to apply the following transformations on the poin
t (−2,4) :
# (I) Shearing in Y direction by 7 units.
# (II) Scaling in X and Y direction by 7/2 and 7 units respectively.
# (III) Shearing in X and Y direction by 4 and 7 units respectively.
# (IV) Rotation about origin by an angle 60◦.

import numpy as np
P=np.array([-2,4])
# (I) Shearing in Y direction by 7 units.
shearing_y1 = [P[0], P[1] + (7 * P[0])]
# (II) Scaling in X and Y direction by 7/2 and 7
scaling_x = np.array([7/2, 1]) * P 
scaling_y = np.array([1, 7]) * P 
# (III) Shearing in X and Y direction by 4 and 7 units respectively.
shearing_x = [P[0] + (4 * P[1]), P[1]]
shearing_y = [P[0], P[1] + (7 * P[0])]
# (IV) Rotation about origin by an angle 60◦.
rotation_matrix = np.array([[np.cos(np.pi/3), -np.sin(np.pi/3)], 
                          [np.sin(np.pi/3), np.cos(np.pi/3)]]) 
P_rotation = np.dot(rotation_matrix, P)

print("Original point P:", P)
print("Shearing in Y direction:", shearing_y1) 
print("Scaling in X-coordinates by factor 7/2:", scaling_x) 
print("Scaling in Y-coordinates by factor 7:", scaling_y) 
print(" Shearing in both X and Y direction by 4 and 7 units respectively:")
print("Shearing in X direction:", shearing_x)
print("Shearing in Y direction:", shearing_y) 
print("Rotation about origin through an angle of 60 degree:",P_rotation)

Original point P: [-2  4]
Shearing in Y direction: [-2, -10]
Scaling in X-coordinates by factor 7/2: [-7.  4.]
Scaling in Y-coordinates by factor 7: [-2 28]
Shearing in both X and Y direction by 4 and 7 units respectively:

Shearing in X direction: [14, 4]
Shearing in Y direction: [-2, -10]
Rotation about origin through an angle of 60 degree: [-4.46410162  0.267949
19]

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip9.html?t=1713115110640 5/5



4/14/24, 10:49 PM slip10

In [3]: # Represent the following information using a bar graph (in green color )
# Item               clothing Food rent Petrol Misc.
# expenditure in Rs  600     4000  2000  1500   700

import matplotlib.pyplot as plt  
left = [1,2,3,4,5] 
height = [600,4000,2000,1500,700] 
tick_label=['clothing','food','rent','petrol','Misc'] 
plt.bar(left , height ,tick_label=tick_label, width = 0.8 ,color = ['gree
n','red']) 
plt.xlabel('Item') 
plt.ylabel('Expenditure') 
plt. show()

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip10.html?t=1713115161889 1/5



4/14/24, 10:49 PM slip10

In [4]: # Write a python program to plot the 3D line graph whose parametric equatio
n is (cos(2x),sin(2x),x)
# for 10 ≤x ≤20 (in red color ), with title to the graph.

import numpy as np 
import matplotlib.pyplot as plt 
from mpl_toolkits.mplot3d import Axes3D 

x = np.linspace(10, 20, 500) 
# Calculate parametric equations for x, y, z 
y = np.sin(2 * x) 
z = x 
x = np.cos(2 * x) 
# Create a 3D figure 
fig = plt.figure() 
ax = fig.add_subplot(111, projection='3d') 
ax.plot(x, y, z, color='red') 

ax.set_title("3D Line Graph: (cos(2x), sin(2x), x)") 
ax.set_xlabel('X') 
ax.set_ylabel('Y') 
ax.set_zlabel('Z') 
plt.show()

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip10.html?t=1713115161889 2/5



4/14/24, 10:49 PM slip10

In [5]: # Write a python program to rotate the ∆ABC by 90◦ where A(1,1),B(2,−2),C
(1,2)

import numpy as np 
# Define the original points 
A = np.array([1, 1])
B = np.array([2, -2]) 
C = np.array([1, 2]) 

# Define the rotation matrix for rotation by 90 degrees counterclockwise 
angle = np.radians(90) 
rotation_matrix = np.array([[np.cos(angle), -np.sin(angle)], 
                           [np.sin(angle), np.cos(angle)]]) 
# Apply the rotation to the points 
A_rotated = np.dot(rotation_matrix, A) 
B_rotated = np.dot(rotation_matrix, B) 
C_rotated = np.dot(rotation_matrix, C) 
# Print the rotated points 
print("Rotated Point A: ", A_rotated) 
print("Rotated Point B: ", B_rotated) 
print("Rotated Point C: ", C_rotated)

Rotated Point A:  [-1.  1.]
Rotated Point B:  [2. 2.]
Rotated Point C:  [-2.  1.]

In [6]: # Find the area and perimeter of the ∆ABC, where A[0,0],B[5,0],C[3,3]

import numpy as np 

A = np.array([0, 0]) 
B = np.array([5, 0]) 
C = np.array([3, 3]) 

AB = np.linalg.norm(B - A) 
BC = np.linalg.norm(C - B) 
CA = np.linalg.norm(A - C) 

s = (AB + BC + CA) / 2 
area = np.sqrt(s * (s - AB) * (s - BC) * (s - CA)) 
perimeter = AB + BC + CA 

print("Triangle ABC:") 
print("Side AB:", AB) 
print("Side BC:", BC) 
print("Side CA:", CA) 
print("Area:", area) 
print("Perimeter:", perimeter)

Triangle ABC:
Side AB: 5.0
Side BC: 3.605551275463989
Side CA: 4.242640687119285
Area: 7.5000000000000036
Perimeter: 12.848191962583275

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip10.html?t=1713115161889 3/5



4/14/24, 10:49 PM slip10

In [7]: # Solve LPP by using python:
# Max Z = x + y
# subject to x −y ≥1
# x + y ≥2
# x ≥0,y ≥0

from pulp import * 

problem = LpProblem("LPP", LpMaximize) 

x = LpVariable('x', lowBound=0, cat='Continuous') 
y = LpVariable('y', lowBound=0, cat='Continuous') 
# Define the objective function 
Z= x + y
problem += Z 
# Define the constraints 
problem +=  x - y >=1
problem +=  x +  y >=2
# Solve the LP problem 
problem.solve() 
# Print the status of the solution 
print("Status:", LpStatus[problem.status]) 
print("Optimal x =", value(x)) 
print("Optimal y =", value(y)) 
print("Optimal Z =", value(problem.objective))

Status: Unbounded
Optimal x = 0.0
Optimal y = 0.0
Optimal Z = 0.0

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip10.html?t=1713115161889 4/5



4/14/24, 10:49 PM slip10

In [8]: # Write a python program to apply the following transformations on the poin
t (−2,4) :
# (I) Refection through X−axis.
# (II) Scaling in X−coordinate by factor 6.
# (III) Shearing in X direction by 4 units.
# (IV) Rotate about origin through an angle 30◦.

import numpy as np
P=np.array([-2,4])

# (I) Refection through X−axis.
reflection_x_axis = np.array([1, -1]) * P 
# (II) Scaling in X−coordinate by factor 6.
scaling_x = np.array([6, 1]) * P
# (III) Shearing in X direction by 4 units.
shearing_x = [P[0] + (4 * P[1]), P[1]]
# (IV) Rotate about origin through an angle 30◦.
rotation_matrix = np.array([[np.cos(np.pi/6), -np.sin(np.pi/6)], 
                          [np.sin(np.pi/6), np.cos(np.pi/6)]]) 
P_rotation = np.dot(rotation_matrix, P)

print("Original point P:", P) 
print("Reflection through x-axis:", reflection_x_axis)
print("Scaling in X-coordinates by factor 6:", scaling_x) 
print("Shearing in X direction:", shearing_x)
print("Rotation about origin through an angle of 30 degree:",P_rotation)

Original point P: [-2  4]
Reflection through y-axis: [-2 -4]
Scaling in X-coordinates by factor 6: [-12   4]
Shearing in X direction: [14, 4]
Rotation about origin through an angle of 30 degree: [-3.73205081  2.464101
62]

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip10.html?t=1713115161889 5/5



4/14/24, 10:50 PM slip11

In [1]: # Plot the graph of y = e−x2 in [−5,5] with red dashed-points line with Upw
ard Pointing triangle

import matplotlib.pyplot as plt 
import numpy as np 
# Generate x values in the range [-5,5] 
x = np.linspace(-5, 5, 100) 
# Compute y values using y = e**-x 
y = np.exp(-x) 
# Create a figure and axis 
fig, ax = plt.subplots() 
# Plot the graph with red dashed line and upward pointing triangles as mark
ers 
ax.plot(x, y, 'r--', marker='^') 
# Set labels for the x-axis and y-axis 
ax.set_xlabel('x') 
ax.set_ylabel('y') 
# Set title for the plot 
ax.set_title('Graph of y = e**-x') 
# Display the plot 
plt.show()

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip11.html?t=1713115212528 1/5



4/14/24, 10:50 PM slip11

In [3]: # Draw a bar graph in GREEN colour to represent the data below:
# Subject                 Maths Science English Marathi Hindi
# Percentage of passing   68      90     70      85      91

import matplotlib.pyplot as plt  
left = [1,2,3,4,5] 
height = [68,90,70,85,91] 
tick_label=['Maths','Science','English','Marathi','Hindi'] 
plt.bar (left,height,tick_label = tick_label,width = 0.8 ,color = ['gree
n','green']) 
plt.xlabel('Subject') 
plt.ylabel('Percentage of passing') 
plt. show()

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip11.html?t=1713115212528 2/5



4/14/24, 10:50 PM slip11

In [4]: # Write a python program to rotate the ∆ABC by 90◦ where A(1,2),B(2,−2),C
(−1,2)

import numpy as np 

A = np.array([1, 2]) 
B = np.array([2, -2]) 
C = np.array([-1, 2]) 

# Define the rotation matrix for rotation by 90 degrees counter clockwise 
angle = np.radians(90) 
rotation_matrix = np.array([[np.cos(angle), -np.sin(angle)], 
                           [np.sin(angle), np.cos(angle)]]) 
# Apply the rotation to the points 
A_rotated = np.dot(rotation_matrix, A) 
B_rotated = np.dot(rotation_matrix, B) 
C_rotated = np.dot(rotation_matrix, C) 
# Print the rotated points 
print("Rotated Point A: ", A_rotated) 
print("Rotated Point B: ", B_rotated) 
print("Rotated Point C: ", C_rotated)

Rotated Point A:  [-2.  1.]
Rotated Point B:  [2. 2.]
Rotated Point C:  [-2. -1.]

In [5]: #Write a python program to reflect the ∆ABC through the line y = 3 where A
(1,0),B(2,−1),C(−1,3)

import numpy as np 
# Define the reflection line y = 3 
reflection_line = 3 
# Define the points A, B, and C 
A = np.array([1, 0]) 
B = np.array([2, -2]) 
C = np.array([-1, 2]) 
# Compute the reflected points A', B', and C' 
Ap = np.array([A[0], 2 * reflection_line - A[1]]) 
Bp = np.array([B[0], 2 * reflection_line - B[1]]) 
Cp = np.array([C[0], 2 * reflection_line - C[1]]) 
# Print the original points and reflected points 
print("Original Points:") 
print("A: ", A) 
print("B: ", B) 
print("C: ", C) 
print("Reflected Points:") 
print("A':", Ap) 
print("B':", Bp) 
print("C':", Cp)

Original Points:
A:  [1 0]
B:  [ 2 -2]
C:  [-1  2]
Reflected Points:
A': [1 6]
B': [2 8]
C': [-1  4]

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip11.html?t=1713115212528 3/5



4/14/24, 10:50 PM slip11

In [7]: # Solve LPP by using python:
# Min Z = x + y
# subject to x ≥6
# y ≥6
# x + y ≥11
# x ≥0,y ≥0

from pulp import * 

problem= LpProblem("Minimize Z", LpMinimize) 
x= LpVariable("x", lowBound=0, cat='Continuous') 
y= LpVariable("y", lowBound=0, cat='Continuous') 

Z =  x +  y
problem+= Z

problem+= x >= 6
problem+= y >= 6
problem+= x + y >=11

problem.solve() 

print("Status:", LpStatus[problem.status])
print("x =", value(x)) 
print("y =", value(y)) 
print("Optimal value of Z =",value(problem.objective))

Status: Optimal
x = 6.0
y = 6.0
Optimal value of Z = 12.0

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip11.html?t=1713115212528 4/5



4/14/24, 10:50 PM slip11

In [1]: # Write a python program to apply the following transformations on the poin
t (−2,4) :
# (I) Shearing in Y direction by 7 units.
# (II) Scaling in X and Y direction by 3/2 and 4 units respectively.
# (III) Shearing in X and Y direction by 2 and 4 units respectively.
# (IV) Rotation about origin by an angle 45◦

import numpy as np
P=np.array([-2,4])
# (I) Shearing in Y direction by 7 units
shearing_y1 = [P[0], P[1] + (7 * P[0])]
# (II) Scaling in X and Y direction by 3/2 and 4
P_scaled = np.array([P[0] * 3/2, P[1] * 4])
#  (III) Shearing in X and Y direction by 2 and 4 units respectively.
P_sheared = np.array([P[0] + (2 * P[1]), P[1] + (4 * P[0])])

# (IV) Rotation about origin by an angle 45◦
rotation_matrix = np.array([[np.cos(np.pi/4), -np.sin(np.pi/4)], 
                          [np.sin(np.pi/4), np.cos(np.pi/4)]]) 
P_rotation = np.dot(rotation_matrix, P)

print("Original point P:", P)
print("Shearing in Y direction by 7 unit:", shearing_y1)
print("Scaling in X and Y direction by 3/2 and 4:",P_scaled)
print("Shearing in X and Y direction by 2 and 4 units:",P_sheared)
print("Rotation about origin through an angle of 45 degree:",P_rotation)

Original point P: [-2  4]
Shearing in Y direction by 7 unit: [-2, -10]
Scaling in X and Y direction by 3/2 and 4: [-3. 16.]
Shearing in X and Y direction by 2 and 4 units: [ 6 -4]
Rotation about origin through an angle of 60 degree: [-4.24264069  1.414213
56]

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip11.html?t=1713115212528 5/5



4/14/24, 10:52 PM slip12

In [3]: # Write a python program to plot the graph of y = x3 + 10x −5, for x ∈[−10,
10] in red colour
import numpy as np 
import matplotlib.pyplot as plt 

# Generate x values in the range [-10, 10] 
x = np.linspace(-10, 10, 500) 
y = x**3 + 10*x - 5 

plt.plot(x, y, color='red') 
# Set the plot title and axis labels 
plt.title("Graph of y = x**3 + 10*x - 5") 
plt.xlabel("x") 
plt.ylabel("y") 
# Show the plot 
plt.show()

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip12.html?t=1713115263347 1/5



4/14/24, 10:52 PM slip12

In [5]: # Using Python plot the graph of function f(x) = x2 on the interval [−2,2]

import numpy as np 
import matplotlib.pyplot as plt 

# Generate x values in the range (-2,2) with a step of 0.1 
x = np.arange(-2, 2, 0.1) 
y = x**2
# Create the plot 
plt.plot(x, y, label='f(x) = x^2',color='red') 

plt.title('Graph of f(x) = x^2') 
plt.xlabel('x') 
plt.ylabel('f(x)') 
# Add a legend 
plt.legend() 
plt.show()

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip12.html?t=1713115263347 2/5



4/14/24, 10:52 PM slip12

In [6]: # Write a python program to rotate the segment by 180◦ having end points 
(1,0) and (2,−1).

import math 
# Define the endpoints of the line segment 
x1, y1 = 1, 0 
x2, y2 = 2, -1 
# Perform the rotation 
x1_rotated = -x1 
y1_rotated = -y1 
x2_rotated = -x2 
y2_rotated = -y2 
# Print the original and rotated endpoints 
print("Original Endpoint 1: ({}, {})".format(x1, y1)) 
print("Original Endpoint 2: ({}, {})".format(x2, y2)) 
print("Rotated Endpoint 1: ({}, {})".format(x1_rotated, y1_rotated)) 
print("Rotated Endpoint 2: ({}, {})".format(x2_rotated, y2_rotated))

Original Endpoint 1: (1, 0)
Original Endpoint 2: (2, -1)
Rotated Endpoint 1: (-1, 0)
Rotated Endpoint 2: (-2, 1)

In [8]: # Write a python program to find the area and perimeter of the ∆XY Z, where 
X(1,2),Y (2,−2), Z(−1,2)

import math 
# Input coordinates 
X = [1, 2] 
Y = [2, -2] 
Z = [-1, 2] 
# Calculate distances between points 
def distance(p1, p2): 
   return math.sqrt((p2[0] - p1[0]) ** 2 + (p2[1] - p1[1]) ** 2) 
# Calculate lengths of sides 
XY = distance(X, Y) 
YZ = distance(Y, Z) 
XZ = distance(X, Z) 
# Calculate perimeter 
perimeter = XY + YZ + XZ 
# Calculate area using Heron's formula 
s = perimeter / 2 
area = math.sqrt(s * (s - XY) * (s - YZ) * (s - XZ)) 
# Print results 
print("Length of XY: ", XY) 
print("Length of YZ: ", YZ) 
print("Length of XZ: ", XZ) 
print("Perimeter: ", perimeter) 
print("Area: ", area)

Length of XY:  4.123105625617661
Length of YZ:  5.0
Length of XZ:  2.0
Perimeter:  11.123105625617661
Area:  4.000000000000003

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip12.html?t=1713115263347 3/5



4/14/24, 10:52 PM slip12

In [10]: # Write a program to solve the following LPP:
# Min Z = 3.5x + 2y
# subject to x + y ≥5
# x ≥4
# y ≤2
# x ≥0,y ≥0

from pulp import * 

problem= LpProblem("Minimize Z", LpMinimize) 
x= LpVariable("x", lowBound=0, cat='Continuous') 
y= LpVariable("y", lowBound=0, cat='Continuous') 

Z = 3.5 * x + 2 * y 
problem+= Z 

problem+= x + y >= 5
problem+= x >= 4 
problem+= y <= 2 

problem.solve()

print("Status:", LpStatus[problem.status])  
print("x =", value(x))
print("y =", value(y)) 
print("Optimal value of Z =",value(problem.objective))

Status: Optimal
x = 4.0
y = 1.0
Optimal value of Z = 16.0

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip12.html?t=1713115263347 4/5



4/14/24, 10:52 PM slip12

In [12]: # Write a python program to apply the following transformations on the poin
t [−2,4]
# (I) Refection through Y− axis.
# (II) Scaling in X−coordinate by factor 6.
# (III) Scaling in Y−coordinate by factor 4.1.
# (IV) Shearing in X direction by 7/2 units.

import numpy as np

P=np.array([-2,4])
# (I) Refection through Y− axis.
reflection_y_axis = np.array([-1, 1]) * P
# (II) Scaling in X−coordinate by factor 6
scaling_x = np.array([6, 1]) * P
# (III) Scaling in Y−coordinate by factor 4.1
scaling_y = np.array([1, 4.1]) * P 
# (IV) Shearing in X direction by 7/2 units.
shearing_x = [P[0] + ((7/2) * P[1]), P[1]]

print("Original point P:", P) 
print("Reflection through y-axis:", reflection_y_axis) 
print("Scaling in X-coordinates by factor 6:", scaling_x) 
print("Scaling in Y-coordinates by factor 4.1:", scaling_y)
print("Shearing in X direction:", shearing_x)

Original point P: [-2  4]
Reflection through y-axis: [2 4]
Scaling in X-coordinates by factor 6: [-12   4]
Scaling in Y-coordinates by factor 4.1: [-2.  16.4]
Shearing in X direction: [12.0, 4]

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip12.html?t=1713115263347 5/5



4/14/24, 10:53 PM slip13

In [1]: # Write a Python program to plot 2D graph of the functions f(x) = x2 and g
(x) = x3 in [−1,1]

import matplotlib.pyplot as plt
import numpy as np

def f(x):
   return x**2
def g(x):
   return x**3

x=np.linspace(-1,1,100)
y_f=f(x)
y_g=g(x)
fig,ax=plt.subplots()
ax.plot(x,y_f,label='f(x)=x^2')
ax.plot(x,y_g,label='g(x)=x^3')
ax.set_xlabel('x')
ax.set_ylabel('y')
ax.legend()
ax.set_title('2D graph of f(x)=x^2 and g(x)=x^3')
plt.show()

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip13.html?t=1713115362297 1/5



4/14/24, 10:53 PM slip13

In [2]: # Using Python, plot the surface plot of parabola z = x2 + y2 in −6 < x,y < 
6.

import numpy as np 
import matplotlib.pyplot as plt 
from mpl_toolkits.mplot3d import Axes3D 
# Generate values for x and y 
x = np.linspace(-6, 6, 100) 
y = np.linspace(-6, 6, 100) 
X, Y = np.meshgrid(x, y) 
# Calculate values for z based on the parabola equation 
Z = X**2 + Y**2 
# Create a 3D figure 
fig = plt.figure() 
ax = fig.add_subplot(111, projection='3d') 
# Plot the surface plot 
surf = ax.plot_surface(X, Y, Z, cmap='viridis') 

ax.set_xlabel('X') 
ax.set_ylabel('Y') 
ax.set_zlabel('Z') 
ax.set_title('Surface Plot of z = x**2 + y**2') 
# Show the plot 
plt.show()

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip13.html?t=1713115362297 2/5



4/14/24, 10:53 PM slip13

In [4]: # Using sympy declare the points P(5,2),Q(5,−2),R(5,0), check whether these 
points are collinear.
# Declare the ray passing through the points P and Q, find the length of th
is ray between P and Q. Also find slope of this ray

from sympy import * 
# Declare the points P, Q, and R 
P = Point(5, 2) 
Q = Point(5, -2) 
R = Point(5, 0) 
# Check if points P, Q, and R are collinear 
collinear = Point.is_collinear(P, Q, R) 
if collinear: 
   print("Points P, Q, and R are collinear.") 
else: 
   print("Points P, Q, and R are not collinear.") 
# Declarethe ray passing through points P and Q 
ray_PQ = Ray(P, Q) 
# Find the length of the ray between points P and Q 
length_PQ = ray_PQ.length 
print("Length of ray PQ between points P and Q:", length_PQ) 
# Find the slope of the ray PQ 
slope_PQ = ray_PQ.slope 
print("Slope of ray PQ:", slope_PQ)

Points P, Q, and R are collinear.
Length of ray PQ between points P and Q: oo
Slope of ray PQ: oo

In [5]: # Find the area and perimeter of the ∆ABC, where A[0,0],B[5,0],C[3,3].

import numpy as np 

A = np.array([0, 0]) 
B = np.array([5, 0]) 
C = np.array([3, 3]) 

AB = np.linalg.norm(B - A) 
BC = np.linalg.norm(C - B) 
CA = np.linalg.norm(A - C) 
# Calculate the semiperimeter 
s = (AB + BC + CA) / 2 
# Calculate the area using Heron's formula 
area = np.sqrt(s * (s - AB) * (s - BC) * (s - CA)) 
# Calculate the perimeter 
perimeter = AB + BC + CA 
# Print the results 
print("Triangle ABC:") 
print("Side AB:", AB) 
print("Side BC:", BC) 
print("Side CA:", CA) 
print("Area:", area) 
print("Perimeter:", perimeter)

Triangle ABC:
Side AB: 5.0
Side BC: 3.605551275463989
Side CA: 4.242640687119285
Area: 7.5000000000000036
Perimeter: 12.848191962583275

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip13.html?t=1713115362297 3/5



4/14/24, 10:53 PM slip13

In [6]: # Write a Python program to solve the following LPP:
# Max Z = 5x + 3y
# subject to x + y ≤7
# 2x + 5y ≤1
# x ≥0,y ≥0

from pulp import * 
# Create the LP problem as a maximization problem 
problem = LpProblem("LPP", LpMaximize) 
# Define the decision variables 
x = LpVariable('x', lowBound=0, cat='Continuous') 
y = LpVariable('y', lowBound=0, cat='Continuous') 
# Define the objective function 
Z=5 * x + 3 * y
problem += Z 
# Define the constraints 
problem +=  x +  y <= 7 
problem += 2 * x + 5 * y <= 1  
# Solve the LP problem 
problem.solve() 
# Print the status of the solution 
print("Status:", LpStatus[problem.status]) 
# Print the optimal values of x and y 
print("Optimal x =", value(x)) 
print("Optimal y =", value(y)) 
# Print the optimal value of the objective function 
print("Optimal Z =", value(problem.objective))

Status: Optimal
Optimal x = 0.5
Optimal y = 0.0
Optimal Z = 2.5

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip13.html?t=1713115362297 4/5



4/14/24, 10:53 PM slip13

In [4]: # Write a python program to apply the following transformations on the poin
t (−2,4) :
# (I) Shearing in Y direction by 7 units.
# (II) Scaling in X and Y direction by 7/2 and 7 units respectively.
# (III) Shearing in X and Y direction by 4 and 7 units respectively.
# (IV) Rotation about origin by an angle 60◦

import numpy as np
P=np.array([-2,4])
# (I) Shearing in Y direction by 7 units.
shearing_y1 = [P[0], P[1] + (7 * P[0])]
# (II) Scaling in X and Y direction by 7/2 and 7
P_scaled = np.array([P[0] * 7/2, P[1] * 7])
# (III) Shearing in X and Y direction by 4 and 7 units respectively.
P_sheared = np.array([P[0] + (4 * P[1]), P[1] + (7 * P[0])])
# (IV) Rotation about origin by an angle 60◦.
rotation_matrix = np.array([[np.cos(np.pi/3), -np.sin(np.pi/3)], 
                          [np.sin(np.pi/3), np.cos(np.pi/3)]]) 
P_rotation = np.dot(rotation_matrix, P)

print("Original point P:", P)
print("Shearing in Y direction:", shearing_y1) 
print("Scaling in X and Y direction by 7/2 and 7",P_scaled) 
print("Shearing in X and Y direction by 4 and 7 units:",P_sheared) 
print("Rotation about origin through an angle of 60 degree:",P_rotation)

Original point P: [-2  4]
Shearing in Y direction: [-2, -10]
Scaling in X and Y direction by 7/2 and 7 [-7. 28.]
Shearing in X and Y direction by 4 and 7 units: [ 14 -10]
Rotation about origin through an angle of 60 degree: [-4.46410162  0.267949
19]

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip13.html?t=1713115362297 5/5



4/14/24, 10:54 PM slip14

In [1]: # Write a Python program to plot 2D graph of the functions f(x) = x2 and g
(x) = x3 in [−1,1]
import matplotlib.pyplot as plt
import numpy as np

def f(x):
   return x**2
def g(x):
   return x**3

x=np.linspace(-1,1,100)
y_f=f(x)
y_g=g(x)
fig,ax=plt.subplots()
ax.plot(x,y_f,label='f(x)=x^2')
ax.plot(x,y_g,label='g(x)=x^3')
ax.set_xlabel('x')
ax.set_ylabel('y')
ax.legend()
ax.set_title('2D graph of f(x)=x^2 and g(x)=x^3')
plt.show()

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip14.html?t=1713115417322 1/6



4/14/24, 10:54 PM slip14

In [2]: # Write a Python program to generate 3D plot of the function z = sin(x) + c
os(y) in −5 < x,y < 5

import numpy as np 
import matplotlib.pyplot as plt 
from mpl_toolkits.mplot3d import Axes3D 
# Generate data 
x = np.linspace(-5, 5, 100) 
y = np.linspace(-5, 5, 100) 
X, Y = np.meshgrid(x, y) 
Z = np.sin(X) + np.cos(Y) 
# Create 3D plot 
fig = plt.figure() 
ax = fig.add_subplot(111, projection='3d') 
ax.plot_surface(X, Y, Z, cmap='viridis') 
ax.set_xlabel('X') 
ax.set_ylabel('Y') 
ax.set_zlabel('Z') 
ax.set_title('3D Plot of z = sin(x) + cos(y)') 
plt.show()

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip14.html?t=1713115417322 2/6



4/14/24, 10:54 PM slip14

In [5]: # Write a Python program to draw a polygon with vertices (0,0),(2,0),(2,3) 
and (1,6) and rotate it by 180

import matplotlib.pyplot as plt 
import numpy as np 

vertices = np.array([[0, 0], [2, 0], [2, 3], [1, 6]]) 

plt.figure() 
plt.plot(vertices[:, 0], vertices[:, 1], 'bo-') 
plt.title('Original Polygon') 
plt.xlabel('X') 
plt.ylabel('Y') 
# Define the rotation matrix for 180 degrees 
theta = np.pi  # 180 degrees 
rotation_matrix = np.array([[np.cos(theta), -np.sin(theta)], 
                           [np.sin(theta), np.cos(theta)]]) 
# Apply rotation to the vertices 
vertices_rotated = np.dot(vertices, rotation_matrix) 
# Plot the rotated polygon 
plt.figure() 
plt.plot(vertices_rotated[:, 0], vertices_rotated[:, 1], 'ro-') 
plt.title('Rotated Polygon (180 degrees)') 
plt.xlabel('X') 
plt.ylabel('Y') 

plt.show()

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip14.html?t=1713115417322 3/6



4/14/24, 10:54 PM slip14

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip14.html?t=1713115417322 4/6



4/14/24, 10:54 PM slip14

In [6]: # Write a Python program to find the area and perimeter of the triangle AB
C, where A[0,0],B[5,0] and C[3,3].

import numpy as np 

A = np.array([0, 0]) 
B = np.array([5, 0]) 
C = np.array([3, 3]) 

AB = np.linalg.norm(B - A) 
BC = np.linalg.norm(C - B) 
CA = np.linalg.norm(A - C) 
# Calculate the semiperimeter 
s = (AB + BC + CA) / 2 
# Calculate the area using Heron's formula 
area = np.sqrt(s * (s - AB) * (s - BC) * (s - CA)) 
# Calculate the perimeter 
perimeter = AB + BC + CA 
# Print the results 
print("Triangle ABC:") 
print("Side AB:", AB) 
print("Side BC:", BC) 
print("Side CA:", CA) 
print("Area:", area) 
print("Perimeter:", perimeter)

Triangle ABC:
Side AB: 5.0
Side BC: 3.605551275463989
Side CA: 4.242640687119285
Area: 7.5000000000000036
Perimeter: 12.848191962583275

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip14.html?t=1713115417322 5/6



4/14/24, 10:54 PM slip14

In [7]: # Write a Python program to solve the following LPP:
#     Max Z = 150x + 75y
# subject to 4x + 6y ≤24
#            5x + 3y ≤15
# x ≥0,y ≥0

from pulp import * 
# Create the LP problem as a maximization problem 
problem = LpProblem("LPP", LpMaximize) 
# Define the decision variables 
x = LpVariable('x', lowBound=0, cat='Continuous') 
y = LpVariable('y', lowBound=0, cat='Continuous') 
# Define the objective function 
Z= 150*x + 75*y
problem += Z 
# Define the constraints 
problem +=  4*x + 6*y <=24
problem +=  5*x +  3*y <=15
# Solve the LP problem 
problem.solve() 
# Print the status of the solution 
print("Status:", LpStatus[problem.status]) 
# Print the optimal values of x and y 
print("Optimal x =", value(x)) 
print("Optimal y =", value(y)) 
# Print the optimal value of the objective function 
print("Optimal Z =", value(problem.objective))

Status: Optimal
Optimal x = 3.0
Optimal y = 0.0
Optimal Z = 450.0

In [8]: # Apply each of the following transformations on the point P[2,−3].
# I. Reflection through X-axis.
# II. Scaling in X-coordinate by factor 2.
# III. Scaling in Y-coordinate by factor 1.5.
# IV. Reflection through the line y = x

import numpy as np 

P = np.array([2,-3])
reflection_x_axis = np.array([1, -1]) * P
scaling_x = np.array([2, 1]) * P  
scaling_y = np.array([1, 1.5]) * P 
reflection_line = np.array([P[1],P[0]]) 

print("Original point P:", P) 
print("Reflection through y-axis:", reflection_x_axis) 
print("Scaling in X-coordinates by factor 2:", scaling_x) 
print("Scaling in Y-coordinates by factor 1.5:", scaling_y) 
print("Reflection through the line y = x:", reflection_line)

Original point P: [ 2 -3]
Reflection through y-axis: [2 3]
Scaling in X-coordinates by factor 2: [ 4 -3]
Scaling in Y-coordinates by factor 1.5: [ 2.  -4.5]
Reflection through the line y = x: [-3  2]

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip14.html?t=1713115417322 6/6



4/14/24, 10:55 PM slip15

In [1]: # Write the Python program to find area of the triangle ABC, where A[0,0],B
[5,0],C[3,3]
import math 
def calculate_area(x1, y1, x2, y2, x3, y3): 
   area = abs((x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) / 2) 
   return area 
# Coordinates of vertices A, B, and C 
Ax, Ay = 0, 0 
Bx, By = 5, 0 
Cx, Cy = 3, 3 
# Call the function to calculate the area 
area = calculate_area(Ax, Ay, Bx, By, Cx, Cy) 
# Print the result 
print("Area of triangle ABC is:", area)

Area of triangle ABC is: 7.5

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip15.html?t=1713115479465 1/6



4/14/24, 10:55 PM slip15

In [2]: # Write the Python program to plot the graph of the function, using def()
# f(x) = x2 + 4        if −10 ≤x < 5
#        3x + 9        if 5 ≤x < 10
import numpy as np 
import matplotlib.pyplot as plt 

def f(x): 
   if -10 < x < 5: 
       return x**2 + 4 
   elif 5 <= x: 
       return 3*x + 9 
   else: 
       return None 
# Generate x values 
# Generate 500 points between -11 and 11
x = np.linspace(-11, 11, 500)   
# Calculate y values using f(x) 
y = np.array([f(xi) for xi in x]) 
# Create the plot 
plt.plot(x, y, label='f(x)') 
plt.xlabel('x') 
plt.ylabel('f(x)') 
plt.title('Graph of f(x)') 
plt.legend() 
plt.grid(True) 
plt.show()

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip15.html?t=1713115479465 2/6



4/14/24, 10:55 PM slip15

In [1]: # Write the Python program to rotate the triangle ABC by 180 degree, where 
A[1,2],B[2,−2] & C[−1,2]
import numpy as np 
# Define the original triangle vertices 
A = np.array([1,2]) 
B = np.array([2, -2]) 
C = np.array([-1, 2]) 
# Define the rotation matrix for 180 degrees 
angle = np.radians(180) 
rotation_matrix = np.array([[np.cos(angle), -np.sin(angle)], 
                           [np.sin(angle), np.cos(angle)]]) 
# Rotate the triangle vertices using the rotation matrix 
A_rotated = np.dot(rotation_matrix, A) 
B_rotated = np.dot(rotation_matrix, B) 
C_rotated = np.dot(rotation_matrix, C) 
# Print the rotated triangle vertices 
print("Original Triangle Vertices:") 
print("A:", A) 
print("B:", B) 
print("C:", C) 
print("Rotated Triangle Vertices:") 
print("A Rotated:", A_rotated) 
print("B Rotated:", B_rotated) 
print("C Rotated:", C_rotated)

Original Triangle Vertices:
A: [1 2]
B: [ 2 -2]
C: [-1  2]
Rotated Triangle Vertices:
A Rotated: [-1. -2.]
B Rotated: [-2.  2.]
C Rotated: [ 1. -2.]

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip15.html?t=1713115479465 3/6



4/14/24, 10:55 PM slip15

In [4]: # Write the Python program to plot the graph of function f(x) = ex in the i
nterval [−10,10].
import numpy as np 
import matplotlib.pyplot as plt 

def f(x): 
   return np.exp(x) 

x = np.linspace(-10, 10, 500) 
y = f(x) 

plt.plot(x, y, label='f(x) = e**x') 
plt.xlabel('x') 
plt.ylabel('f(x)') 
plt.title('Graph of f(x) = e**x') 
plt.legend() 
plt.grid(True) 
plt.show()

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip15.html?t=1713115479465 4/6



4/14/24, 10:55 PM slip15

In [6]: # Write a Python program to solve the following LPP:
# Min Z = 3.5x + 2y
# subject to x + y ≥5
# x ≥4
# y ≤2
# x ≥0,y ≥0.

from pulp import * 

problem= LpProblem("Minimize Z", LpMinimize) 
x= LpVariable("x", lowBound=0, cat='Continuous') 
y= LpVariable("y", lowBound=0, cat='Continuous') 

Z = 3.5 * x + 2 * y 
problem+= Z 

problem+= x + y >= 5
problem+= x >= 4 
problem+= y <= 2 

problem.solve() 

print("Status:", LpStatus[problem.status])
print("x =", value(x)) 
print("y =", value(y)) 
print("Optimal value of Z =",value(problem.objective))

Status: Optimal
x = 4.0
y = 1.0
Optimal value of Z = 16.0

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip15.html?t=1713115479465 5/6



4/14/24, 10:55 PM slip15

In [8]: # write a Python program to apply each of the following transformations on 
the point P[−2,4].
# I. Reflection through the line y = x + 1.
# II. Scaling in Y -coordinate by factor 1.5.
# III. Shearing in X direction by 2 units.
# IV. Rotation about origin by an angle 45 degrees.

import numpy as np
P=np.array([-2,4])

print("Original Point:") 
print("Point P: ({}, {})".format(P[0], P[1])) 
# Transformation I: Reflection through the line y = x + 1 
reflection_matrix = np.array([[0, 1], [1,0]])                         
P_reflection = np.dot(reflection_matrix, P) 
print("\nPoint after Reflection:") 
print("Point P: ({}, {})".format(P_reflection[0], P_reflection[1]))

# Transformation II: Scaling in y-coordinate by factor 1.5 
scaling_matrix = np.array([[1, 0], [0, 1.5]])                   
P_scaling = np.dot(scaling_matrix, P_reflection) 
print("\nPoint after Scaling:") 
print("Point P: ({}, {})".format(P_scaling[0], P_scaling[1]))

# Transformation III: Shearing in x-direction by 2 units 
shearing_matrix= np.array([[1, 2], [0,1]])                             
P_shearing = np.dot(shearing_matrix, P_scaling)  
print("\nPoint after Shearing:") 
print("Point P: ({}, {})".format(P_shearing[0], P_shearing[1]))

# Transformation IV: Rotation about origin by an angle of 45 deg
rotation_matrix = np.array([[np.cos(np.pi/4), -np.sin(np.pi/4)], [np.sin(n
p.pi/4), np.cos(np.pi/4)]]) 
P_rotation = np.dot(rotation_matrix, P_shearing) 
print("\nPoint after Rotation:") 
print("Point P: ({}, {})".format(P_rotation[0], P_rotation[1]))

Original Point:
Point P: (-2, 4)

Point after Reflection:
Point P: (4, -2)

Point after Scaling:
Point P: (4.0, -3.0)

Point after Shearing:
Point P: (-2.0, -3.0)

Point after Rotation:
Point P: (0.7071067811865477, -3.5355339059327378)

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip15.html?t=1713115479465 6/6



4/14/24, 10:56 PM slip16

In [1]: # Write a Python program to plot graph of the function f(x,y) = –x2 −y2 whe
n −10 ≤x,y ≤10.

import matplotlib.pyplot as plt 
import numpy as np 
# Define the function 
def f(x, y): 
   return -x**2 - y**2 
# Generate x and y values within the range of -10 to 10 
x = np.linspace(-10, 10, 100) 
y = np.linspace(-10, 10, 100) 
# Create a grid of x and y values 
X, Y = np.meshgrid(x, y) 
# Compute the values of f(x, y) for each (x, y) in the grid 
Z = f(X, Y) 
# Plot the surface using matplotlib 
fig = plt.figure() 
ax = fig.add_subplot(111, projection='3d') 
ax.plot_surface(X, Y, Z, cmap='viridis') 
ax.set_xlabel('X') 
ax.set_ylabel('Y') 
ax.set_zlabel('f(x, y)') 
ax.set_title('Graph of f(x, y) = -x**2 - y**2') 
plt.show()

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip16.html?t=1713115563802 1/5



4/14/24, 10:56 PM slip16

In [2]: # Write a Python program to generate plot of the function f(x) = x2, in the 
interval [−5,5], in figure of size 6 ×6 inches

import matplotlib.pyplot as plt 
import numpy as np 
# Define the function 
def f(x): 
   return x**2 
# Generate x values within the range of [-5, 5] 
x = np.linspace(-5, 5, 100) 
# Compute the values of f(x) for each x in the range 
y = f(x) 
# Create a figure with size 6x6 inches 
fig = plt.figure(figsize=(6, 6)) 
# Plot the graph of the function 
plt.plot(x, y, label='f(x) = x^2') 
plt.xlabel('x') 
plt.ylabel('f(x)') 
plt.title('Graph of f(x) = x^2') 
plt.legend() 
plt.show()

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip16.html?t=1713115563802 2/5



4/14/24, 10:56 PM slip16

In [3]: # Write a Python program to draw a polygon with vertices (0,0),(2,0),(2,3) 
and (1,6) and rotate it by 90
import matplotlib.pyplot as plt 
import numpy as np 

vertices = np.array([[0, 0], [2, 0], [2, 3], [1, 6], [0, 0]]) 
# Plot the original polygon 
plt.plot(vertices[:, 0], vertices[:, 1], label='Original Polygon') 
# Define the rotation angle in degrees 
rotation_angle = 90 
# Convert the rotation angle to radians 
theta = np.radians(rotation_angle) 
# Create the rotation matrix 
rotation_matrix = np.array([[np.cos(theta), -np.sin(theta)],[np.sin(theta), 
np.cos(theta)]])    

# Apply the rotation matrix to the vertices of the polygon 
rotated_vertices = np.dot(vertices, rotation_matrix.T) 
# Plot the rotated polygon 
plt.plot(rotated_vertices[:, 0], rotated_vertices[:, 1], label='Rotated Pol
ygon') 
# Set the aspect ratio to 'equal' for a square plot 
plt.axis('equal')  
plt.legend() 
plt.title('Polygon Rotation') 
plt.show()

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip16.html?t=1713115563802 3/5



4/14/24, 10:56 PM slip16

In [4]: # Write a Python program to Generate vector x in the interval [0,15] using 
numpy package with 100 subintervals

import numpy as np 

start = 0 
end = 15 
# Define the number of subintervals 
num_subintervals = 100 
# Generate the vector x with equally spaced values in the interval [0, 15] 
x = np.linspace(start, end, num=num_subintervals+1) 
# Print the generated vector x 
print("Generated vector x:") 
print(x)

Generated vector x:
[ 0.    0.15  0.3   0.45  0.6   0.75  0.9   1.05  1.2   1.35  1.5   1.65
 1.8   1.95  2.1   2.25  2.4   2.55  2.7   2.85  3.    3.15  3.3   3.45
 3.6   3.75  3.9   4.05  4.2   4.35  4.5   4.65  4.8   4.95  5.1   5.25
 5.4   5.55  5.7   5.85  6.    6.15  6.3   6.45  6.6   6.75  6.9   7.05
 7.2   7.35  7.5   7.65  7.8   7.95  8.1   8.25  8.4   8.55  8.7   8.85
 9.    9.15  9.3   9.45  9.6   9.75  9.9  10.05 10.2  10.35 10.5  10.65
10.8  10.95 11.1  11.25 11.4  11.55 11.7  11.85 12.   12.15 12.3  12.45
12.6  12.75 12.9  13.05 13.2  13.35 13.5  13.65 13.8  13.95 14.1  14.25
14.4  14.55 14.7  14.85 15.  ]

In [6]: # Write a Python program to solve the following LPP:
# Min Z = 3.5x + 2y
# subject to x + y ≥5
# x ≥4
# y ≤2
# x ≥0,y ≥0.

from pulp import * 

problem= LpProblem("Minimize Z", LpMinimize) 
x= LpVariable("x", lowBound=0, cat='Continuous') 
y= LpVariable("y", lowBound=0, cat='Continuous') 

Z = 3.5 * x + 2 * y 
problem+= Z 

problem+= x + y >= 5
problem+= x >= 4 
problem+= y <= 2 

problem.solve() 

print("Status:", LpStatus[problem.status])
print("x =", value(x)) 
print("y =", value(y)) 
print("Optimal value of Z =",value(problem.objective))

Status: Optimal
x = 4.0
y = 1.0
Optimal value of Z = 16.0

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip16.html?t=1713115563802 4/5



4/14/24, 10:56 PM slip16

In [7]: # Write a python program to plot the Triangle with vertices at [4,3],[6,3],
[6,5]. and its reflec-tions through, 1) x-axis, 2) y-axis. All the figures 
must be in different colors, also plot the two axes

import matplotlib.pyplot as plt 
import numpy as np 

triangle_vertices = np.array([[4, 3], [6, 3], [6, 5], [4, 3]]) 
# Reflect the triangle through the x-axis 
x_reflected_vertices = np.array([triangle_vertices[:, 0], -triangle_vertice
s[:, 
1]]).T 
# Reflect the triangle through the y-axis 
y_reflected_vertices = np.array([-triangle_vertices[:, 0], triangle_vertice
s[:, 
1]]).T 
# Plot the original triangle in red color 
plt.plot(triangle_vertices[:, 0], triangle_vertices[:, 1], 'r', label='Orig
inalTriangle') 
# Plot the x-reflected triangle in blue color 
plt.plot(x_reflected_vertices[:, 0], x_reflected_vertices[:, 1], 'b', label
='X-Reflected Triangle') 
# Plot the y-reflected triangle in green color 
plt.plot(y_reflected_vertices[:, 0], y_reflected_vertices[:, 1], 'g', label
='Y-Reflected Triangle') 
# Set the axis labels and title 
plt.xlabel('X-axis') 
plt.ylabel('Y-axis') 
plt.title('Triangle and Its Reflections') 
plt.legend() 
plt.show()

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip16.html?t=1713115563802 5/5



4/14/24, 10:57 PM slip17

In [1]: #Write python program to plot the 3D graph of the function z = x2 + y2 in 
−6 < x,y <6 using surface plot

import matplotlib.pyplot as plt 
import numpy as np 
# Create a meshgrid for x and y values 
x = np.linspace(-6, 6, 100) 
y = np.linspace(-6, 6, 100) 
X, Y = np.meshgrid(x, y) 
# Compute the values of z 
Z = X**2 + Y**2 
# Create a 3D surface plot 
fig = plt.figure() 
ax = fig.add_subplot(111, projection='3d') 
ax.plot_surface(X, Y, Z, cmap='viridis') 
# Set labels and title 
ax.set_xlabel('X-axis') 
ax.set_ylabel('Y-axis') 
ax.set_zlabel('Z-axis') 
ax.set_title('3D Surface Plot of z = x^2 + y^2') 
# Show the plot 
plt.show()

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip17.html?t=1713115606968 1/6



4/14/24, 10:57 PM slip17

In [2]: # Write a python program to plot 3D contours for the function f(x,y) = log
(x2y2) when −5 ≤x,y ≤5, with greens color map.

import matplotlib.pyplot as plt 
import numpy as np 

x = np.linspace(-5, 5, 100) 
y = np.linspace(-5, 5, 100) 
X, Y = np.meshgrid(x, y) 
# Compute the values of f(x, y) 
Z = np.log(X**2 * Y**2) 
# Create a 3D contour plot 
fig = plt.figure() 
ax = fig.add_subplot(111, projection='3d') 
ax.contour(X, Y, Z, cmap='Greens') 
# Set labels and title 
ax.set_xlabel('X-axis') 
ax.set_ylabel('Y-axis') 
ax.set_zlabel('f(x, y)') 
ax.set_title('3D Contour Plot of f(x, y) = log(x^2 * y^2)') 
# Show the plot 
plt.show()

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip17.html?t=1713115606968 2/6



4/14/24, 10:57 PM slip17

In [3]: # Write a python program to rotate the line segment by 180 degrees having e
nd points (1,0) and (2,−1).

import matplotlib.pyplot as plt 
import numpy as np 

A = np.array([1, 0]) 
B = np.array([2, -1]) 
# Find the midpoint of the line segment 
midpoint = (A + B) / 2 
# Define the rotation matrix for 180 degrees 
rotation_matrix = np.array([[-1, 0],[0, -1]])                          
# Rotate the end points of the line segment around the midpoint 
A_rotated = np.dot(rotation_matrix, A - midpoint) + midpoint 
B_rotated = np.dot(rotation_matrix, B - midpoint) + midpoint 
# Plot the original line segment and its rotated version 
fig, ax = plt.subplots() 

ax.plot([A[0], B[0]], [A[1], B[1]], 'b', label='Original Line Segment AB') 

ax.plot([A_rotated[0], B_rotated[0]], [A_rotated[1], B_rotated[1]], 'r', 
label='Rotated Line Segment A\'B\'') 

ax.scatter(midpoint[0],  midpoint[1],  color='g',  marker='o',  label='Midp
oint')

ax.legend() 
ax.set_xlabel('X-axis') 
ax.set_ylabel('Y-axis') 
ax.set_title('Rotation of Line Segment AB by 180 Degrees around Midpoint') 
plt.axis('equal')  
plt.grid(True) 
plt.show()

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip17.html?t=1713115606968 3/6



4/14/24, 10:57 PM slip17

In [4]: # Write a python program to drawn a polygon with vertices (0,0),(1,0),(2,
2),(1,4) and find its area and perimeter.

import matplotlib.pyplot as plt 
import numpy as np 
# Define the vertices of the polygon 
vertices = np.array([[0, 0], [1, 0], [2, 2], [1, 4], [0, 0]]) 
# Extract x and y coordinates of the vertices 
x = vertices[:, 0] 
y = vertices[:, 1] 
# Plot the polygon 
fig, ax = plt.subplots() 
ax.plot(x, y, 'b', label='Polygon') 
# Calculate the area of the polygon 
area = 0.5 * np.abs(np.dot(x, np.roll(y, 1)) - np.dot(y, np.roll(x, 1))) 
# Calculate the perimeter of the polygon 
perimeter = np.sum(np.sqrt(np.diff(x) ** 2 + np.diff(y) ** 2)) 
# Print the calculated area and perimeter 
print("Area of the polygon: ", area) 
print("Perimeter of the polygon: ", perimeter) 
ax.set_xlabel('X-axis') 
ax.set_ylabel('Y-axis') 
ax.set_title('Polygon with Vertices (0, 0), (1, 0), (2, 2), (1, 4)') 
ax.legend() 
plt.grid(True) 
plt.show()

Area of the polygon:  4.0
Perimeter of the polygon:  9.595241580617241

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip17.html?t=1713115606968 4/6



4/14/24, 10:57 PM slip17

In [6]: # Write a Python program to solve the following LPP:
# Max Z =  4x + y + 3z + 5w
# subject to  4x + 6y −5z −4w ≥−20
#            −8x −3y + 3z + 2w ≤20
# x ≥0,y ≥0.

from pulp import * 
# Create the LP problem 
lp_problem = LpProblem("Minimize Z", LpMaximize) 
# Define the decision variables 
x = LpVariable('x', lowBound=0, cat='Continuous') 
y = LpVariable('y', lowBound=0, cat='Continuous') 
z = LpVariable('z', lowBound=0, cat='Continuous') 
w = LpVariable('w', lowBound=0, cat='Continuous') 
# Set the objective function 
Z= 4*x + y + 3*z + 5*w
lp_problem += Z
# Add the constraints 
lp_problem += 4*x + 6*y - 5*z - 4*w >= -20 
lp_problem += -8*x - 3*y + 3*z + 2*w <= 5 
lp_problem += x >= 0 
lp_problem += y >= 0 
# Solve the LP problem 
lp_problem.solve() 
# Print the status of the LP problem 
print("Status: ", LpStatus[lp_problem.status]) 
# Print the optimal values of the decision variables 
print("Optimal Values:") 
print("x = ", x.varValue) 
print("y = ", y.varValue) 
print("z = ", z.varValue) 
print("w = ", w.varValue) 
# Print the optimal value of the objective function 
print("Optimal Objective Function Value = ", value(lp_problem.objective))

Status:  Unbounded
Optimal Values:
x =  0.83333333
y =  0.0
z =  0.0
w =  5.8333333
Optimal Objective Function Value =  32.49999982

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip17.html?t=1713115606968 5/6



4/14/24, 10:57 PM slip17

In [1]: # Apply each of the following transformations on the point P[3,−1].
# I. Reflection through X-axis.
# II. Scaling in Y-coordinate by factor 1.5.
# III. Shearing in both X and Y direction by -2 and 4 units respectively.
# IV. Rotation about origin by an angle 30 degrees

import numpy as np 

P = np.array([2, -3]) 
# (I) Reflection through X-axis 
reflection_X = np.array([[1, 0],[0, -1]])                         
P_reflection_X = np.dot(reflection_X, P) 
# (II) Scaling in Y-coordinate by factor 1.5 
scaling_Y = np.array([[1, 0],[0, 1.5]]) 
P_scaling_Y = np.dot(scaling_Y, P) 
# (III) Shearing in both X and Y direction by -2 and 4 units respectively 
P_sheared = np.array([P[0] + (-2 * P[1]), P[1] + (4 * P[0])])
# (IV) Rotation about origin by an angle of 30 degrees 
angle = np.radians(30) 
rotation = np.array([[np.cos(angle), -np.sin(angle)],[np.sin(angle), 
np.cos(angle)]])                     
P_rotation = np.dot(rotation, P) 
# Print the results 
print("Original Point P:", P) 
print("Result after reflection through X-axis:", P_reflection_X) 
print("Result after scaling in Y-coordinate by factor 1.5:", P_scaling_Y) 
print("Result  after  shearing  in  both  X  and  Y  direction  by  -2  and 
4  units respectively:", P_sheared) 
print("Result after rotation about origin by an angle of 30 degrees:", P_ro
tation)

Original Point P: [ 2 -3]
Result after reflection through X-axis: [2 3]
Result after scaling in Y-coordinate by factor 1.5: [ 2.  -4.5]
Result  after  shearing  in  both  X  and  Y  direction  by  -2  and  4  un
its respectively: [[ 2  6]
[ 8 -3]]

Result after rotation about origin by an angle of 30 degrees: [ 3.23205081 
-1.59807621]

https://htmtopdf.herokuapp.com/ipynbviewer/temp/82edebd97348fac70cd1030cd2a9b7c7/slip17.html?t=1713115606968 6/6



4/14/24, 11:01 PM slip18

In [2]: # Write a Python program to plot the graph 2x2 −4x + 5 in [–10,10] in magen
ta colored dashed pattern

import numpy as np
import matplotlib.pyplot as plt

# Define the function
def f(x):
   return 2*x**2 - 4*x + 5

# Generate x values
x = np.linspace(-10, 10, 400)

# Generate y values
y = f(x)

# Plot the graph
plt.plot(x, y, color='magenta', linestyle='dashed', label='2x^2 - 4x + 5')

# Add labels and title
plt.xlabel('x')
plt.ylabel('y')
plt.title('Graph of $2x^2 - 4x + 5$')
plt.grid(True)

plt.legend()
plt.show()

https://htmtopdf.herokuapp.com/ipynbviewer/temp/495099c9ac217b4c29128029f1abe805/slip18.html?t=1713115836845 1/5



4/14/24, 11:01 PM slip18

In [3]: # Write a Python program to generate 3D plot of the functions z = x2 + y2 i
n −5 < x,y < 5

import numpy as np 
import matplotlib.pyplot as plt 
from mpl_toolkits.mplot3d import Axes3D 

x = np.linspace(-5, 5, 100) 
y = np.linspace(-5, 5, 100) 
# Create a grid of x, y values 
X, Y = np.meshgrid(x, y) 
# Compute the corresponding z values using the function z = x^2 + y^2 
Z = X**2 + Y**2 
# Create a 3D figure 
fig = plt.figure() 
ax = fig.add_subplot(111, projection='3d') 
# Plot the surface 
ax.plot_surface(X, Y, Z, cmap='viridis') 
# Set labels for x, y, and z axes 
ax.set_xlabel('x') 
ax.set_ylabel('y') 
ax.set_zlabel('z') 
# Set title 
ax.set_title('3D Plot of z = x^2 + y^2') 
# Show the plot 
plt.show()

https://htmtopdf.herokuapp.com/ipynbviewer/temp/495099c9ac217b4c29128029f1abe805/slip18.html?t=1713115836845 2/5



4/14/24, 11:01 PM slip18

In [9]: # Write a Python program to generate vector x in the interval [−22,22] usin
g numpy package with 80 subintervals

import numpy as np 

start = -22 
end = 22 
num_subintervals = 80 

x = np.linspace(start, end ,num = num_subintervals+1) 
# Print the generated vector x 
print(x)

[-22.   -21.45 -20.9  -20.35 -19.8  -19.25 -18.7  -18.15 -17.6  -17.05
-16.5  -15.95 -15.4  -14.85 -14.3  -13.75 -13.2  -12.65 -12.1  -11.55
-11.   -10.45  -9.9   -9.35  -8.8   -8.25  -7.7   -7.15  -6.6   -6.05
 -5.5   -4.95  -4.4   -3.85  -3.3   -2.75  -2.2   -1.65  -1.1   -0.55
  0.     0.55   1.1    1.65   2.2    2.75   3.3    3.85   4.4    4.95
  5.5    6.05   6.6    7.15   7.7    8.25   8.8    9.35   9.9   10.45
 11.    11.55  12.1   12.65  13.2   13.75  14.3   14.85  15.4   15.95
 16.5   17.05  17.6   18.15  18.7   19.25  19.8   20.35  20.9   21.45
 22.  ]

In [11]: # Write a Python program to rotate the triangle ABC by 90 degree, where A
[1,2],B[2,−2]andC[−1,2]
import numpy as np 

A = np.array([1, 2]) 
B = np.array([2, -2]) 
C = np.array([-1, 2]) 

# Define the rotation matrix for rotation by 90 degrees counter clockwise 
angle = np.radians(90) 
rotation_matrix = np.array([[np.cos(angle), -np.sin(angle)], 
                           [np.sin(angle), np.cos(angle)]]) 
# Apply the rotation to the points 
A_rotated = np.dot(rotation_matrix, A) 
B_rotated = np.dot(rotation_matrix, B) 
C_rotated = np.dot(rotation_matrix, C) 
# Print the rotated points 
print("Rotated Point A: ", A_rotated) 
print("Rotated Point B: ", B_rotated) 
print("Rotated Point C: ", C_rotated)

Rotated Point A:  [-2.  1.]
Rotated Point B:  [2. 2.]
Rotated Point C:  [-2. -1.]

https://htmtopdf.herokuapp.com/ipynbviewer/temp/495099c9ac217b4c29128029f1abe805/slip18.html?t=1713115836845 3/5



4/14/24, 11:01 PM slip18

In [16]: # write a Python program to solve the following LPP:
# Min Z = x + y
# subject to x ≥6
# y ≥6
# x + y ≤11
# x ≥0,y ≥0

from pulp import *

problem= LpProblem("Minimize Z", LpMinimize) 
x= LpVariable("x", lowBound=0, cat='Continuous') 
y= LpVariable("y", lowBound=0, cat='Continuous') 

Z =  x + y 
problem+= Z 

problem+= x  >= 6
problem+= y >= 6 
problem+=  x + y <=11

problem.solve() 

print("Status:", LpStatus[problem.status])

if problem.status==LpStatusOptimal:
                 print("Status:", LpStatus[problem.status])
                 print("x =", value(x)) 
                 print("y =", value(y)) 
                 print("Optimal value of Z =",value(problem.objective))

Status: Infeasible

https://htmtopdf.herokuapp.com/ipynbviewer/temp/495099c9ac217b4c29128029f1abe805/slip18.html?t=1713115836845 4/5



4/14/24, 11:01 PM slip18

In [ ]: # Apply each of the following transformations on the point P[3,−1].
# I. Reflection through Y-axis.
# II. Scaling in X and Y direction by 1/2 and 3 units respectively.
# III. Shearing in both X and Y direction by -2 and 4 units respectively.
# IV. Rotation about origin by an angle 60 degrees.

import numpy as np

# Define the point P
P = np.array([3, -1])

# I. Reflection through Y-axis
P_reflected = np.array([-P[0], P[1]])

# II. Scaling in X and Y direction by 1/2 and 3 units respectively
P_scaled = np.array([P[0] * 0.5, P[1] * 3])

# III. Shearing in both X and Y direction by -2 and 4 units respectively
P_sheared = np.array([P[0] + (-2 * P[1]), P[1] + (4 * P[0])])

# IV. Rotation about origin by an angle 60 degrees

rotation_matrix = np.array([[np.cos(np.pi/3), -np.sin(np.pi/3)], [np.sin(n
p.pi/3), np.cos(np.pi/3)]])
P_rotated = np.dot(rotation_matrix, P)

# Print the results
print("Original point P:", P)
print("I. Reflection through Y-axis:", P_reflected)
print("II. Scaled point:", P_scaled)
print("III. Sheared point:", P_sheared)
print("IV. Rotated point:", P_rotated)

https://htmtopdf.herokuapp.com/ipynbviewer/temp/495099c9ac217b4c29128029f1abe805/slip18.html?t=1713115836845 5/5



4/14/24, 11:02 PM slip19

https://htmtopdf.herokuapp.com/ipynbviewer/temp/495099c9ac217b4c29128029f1abe805/slip19.html?t=1713115914521 1/8



4/14/24, 11:02 PM slip19

In [9]: # Write a python program to plot the graphs of sin(x),ex and x3 in [0,5] in 
one figure with 2 ×2 subplots

import numpy as np
import matplotlib.pyplot as plt

# Define the range
x = np.linspace(0, 5, 100)

# Calculate the functions
y1 = np.sin(x)
y2 = np.exp(x)
y3 = x**3

# Create subplots
plt.figure(figsize=(10, 8))

plt.subplot(2, 2, 1)
plt.plot(x, y1, 'r')
plt.title('sin(x)')

plt.subplot(2, 2, 2)
plt.plot(x, y2, 'g')
plt.title('exp(x)')

plt.subplot(2, 2, 3)
plt.plot(x, y3, 'b')
plt.title('x^3')
# Adjustbspacing between subplots
plt.tight_layout()
plt.show()

https://htmtopdf.herokuapp.com/ipynbviewer/temp/495099c9ac217b4c29128029f1abe805/slip19.html?t=1713115914521 2/8



4/14/24, 11:02 PM slip19

In [10]: # Write a python program to plot 2D graph of the functions f(x) = log(x) + 
5 and g(x) = log(x) −5 in [0,10] by setting different line width and differ
ent colors to the curve

import numpy as np 
import matplotlib.pyplot as plt 
# Define the functions 
def f(x): 
   return np.log(x) + 5 
def g(x): 
   return np.log(x) - 5

# Generate x values in the range [0, 10] 
x = np.linspace(0.01, 10, 100) 
# Compute y values for f(x) and g(x) 
y_f = f(x) 
y_g = g(x) 
# Create the plot 
plt.plot(x, y_f, label='f(x) = log(x) + 5', linewidth=2, color='blue') 
plt.plot(x, y_g, label='g(x) = log(x) - 5', linewidth=1, color='red') 
# Add labels and legend 
plt.xlabel('x') 
plt.ylabel('y') 
plt.legend() 
plt.title('2D Graph of f(x) and g(x)') 
plt.show()

https://htmtopdf.herokuapp.com/ipynbviewer/temp/495099c9ac217b4c29128029f1abe805/slip19.html?t=1713115914521 3/8



4/14/24, 11:02 PM slip19

In [11]: # Write a python program to rotate the ray by 90o in clockwise direction ha
ving starting point (0,0) and end point (4,4).

import math 
# Define the endpoints of the line segment 
x1, y1 = 0, 0 
x2, y2 = 4, 4 
# Perform the rotation 
x1_rotated = -x1 
y1_rotated = -y1 
x2_rotated = -x2 
y2_rotated = -y2 
# Print the original and rotated endpoints 
print("Original Endpoint 1: ({}, {})".format(x1, y1)) 
print("Original Endpoint 2: ({}, {})".format(x2, y2)) 
print("Rotated Endpoint 1: ({}, {})".format(x1_rotated, y1_rotated)) 
print("Rotated Endpoint 2: ({}, {})".format(x2_rotated, y2_rotated))

Original Endpoint 1: (0, 0)
Original Endpoint 2: (4, 4)
Rotated Endpoint 1: (0, 0)
Rotated Endpoint 2: (-4, -4)

https://htmtopdf.herokuapp.com/ipynbviewer/temp/495099c9ac217b4c29128029f1abe805/slip19.html?t=1713115914521 4/8



4/14/24, 11:02 PM slip19

In [13]: # Write a Python program to Reflect the triangle ABC through the line y=3, 
where A[1,0],B[2,−1] and C[−1,3]

import numpy as np
import matplotlib.pyplot as plt

# Define vertices of the triangle ABC
A = np.array([1, 0])
B = np.array([2, -1])
C = np.array([-1, 3])

# Define the equation of the reflection line y = 3
line = 3

# Reflect each vertex across the reflection line
A_reflected = np.array([A[0], 2 * line - A[1]])
B_reflected = np.array([B[0], 2 * line - B[1]])
C_reflected = np.array([C[0], 2 * line - C[1]])

# Plot the original triangle ABC
plt.plot([A[0], B[0], C[0], A[0]], [A[1], B[1], C[1], A[1]], 'b-', label='T
riangle ABC')

# Plot the reflection of triangle ABC
plt.plot([A_reflected[0], B_reflected[0], C_reflected[0], A_reflected[0]], 
[A_reflected[1], B_reflected[1], C_reflected[1], A_reflected[1]], 'r-', lab
el='Reflected Triangle')

# Plot the reflection line
plt.axhline(y=line, color='g', linestyle='--', label='Reflection Line y=3')

plt.xlabel('X')
plt.ylabel('Y')
plt.title('Reflection of Triangle ABC through the line y=3')
plt.legend()
plt.grid(True)
plt.show()

https://htmtopdf.herokuapp.com/ipynbviewer/temp/495099c9ac217b4c29128029f1abe805/slip19.html?t=1713115914521 5/8



4/14/24, 11:02 PM slip19

https://htmtopdf.herokuapp.com/ipynbviewer/temp/495099c9ac217b4c29128029f1abe805/slip19.html?t=1713115914521 6/8



4/14/24, 11:02 PM slip19

In [16]: # Write a Python program to solve the following LPP:
# Max Z = 3x + 5y + 4z
# subject to 2x + 3y ≤8
# 2y + 5z ≤10
# 3x + 2y + 4z ≤15
# x ≥0,y ≥0

from pulp import * 
# Create the LP prob 
prob = LpProblem("Minimize Z", LpMaximize) 
# Define the decision variables 
x = LpVariable('x', lowBound=0, cat='Continuous') 
y = LpVariable('y', lowBound=0, cat='Continuous') 
z = LpVariable('z', lowBound=0, cat='Continuous') 

# Set the objective function 
Z= 3*x + 5*y + 4*z
prob += Z
# Add the constraints 
prob += 2*x + 3*y <= 8
prob += 2*y + 5*z <= 10 
prob += 3*x + 2*y + 4*z <= 15 
# Solve the LP prob 
prob.solve() 
# Print the status of the LP prob 
print("Status: ", LpStatus[prob.status]) 
# Print the optimal values of the decision variables 
print("Optimal Values:") 
print("x = ", x.varValue) 
print("y = ", y.varValue) 
print("z = ", z.varValue) 
# Print the optimal value of the objective function 
print("Optimal Objective Function Value = ", value(prob.objective))

Status:  Optimal
Optimal Values:
x =  2.1707317
y =  1.2195122
z =  1.5121951
Optimal Objective Function Value =  18.658536500000004

https://htmtopdf.herokuapp.com/ipynbviewer/temp/495099c9ac217b4c29128029f1abe805/slip19.html?t=1713115914521 7/8



4/14/24, 11:02 PM slip19

In [19]: # Find combined transformation of the line segment between the points A
[4,−1] and B[3,0] for
# the following sequence of transformations:
# First rotation about origin through an angle πc; followed by scaling in x 
coordinate by 3 units;
# followed by reflection through the line y = x.

A = np.array([4, -1]) 
B = np.array([3, 0]) 
# Transformation 1: Rotation about origin through an angle pi (180 degrees) 
angle = np.pi 
rotation_matrix = np.array([[np.cos(angle), -np.si(angle)], [np.sin(angle), 
np.cos(angle)]]) 
rotated_A = np.dot(rotation_matrix, A) 
rotated_B = np.dot(rotation_matrix, B) 
# Transformation 2: Scaling in x-coordinate by 3 units 
scaling_factor = np.array([[3, 0], 
                         [0, 1]]) 
scaled_A = np.dot(scaling_factor, rotated_A) 
scaled_B = np.dot(scaling_factor, rotated_B) 
# Transformation 3: Reflection through the line y = x 
reflection_matrix = np.array([[0, 1], 
                             [1, 0]]) 
reflected_A = np.dot(reflection_matrix, scaled_A) 
reflected_B = np.dot(reflection_matrix, scaled_B) 
# Print the results 
print("Initial Points A and B:") 
print("A =", A) 
print("B =", B) 
print("Combined Transformed Points A and B:") 
print("A' =", reflected_A) 
print("B' =", reflected_B)

Initial Points A and B:
A = [ 4 -1]
B = [3 0]
Combined Transformed Points A and B:
A' = [  1. -12.]
B' = [ 3.6739404e-16 -9.0000000e+00]

https://htmtopdf.herokuapp.com/ipynbviewer/temp/495099c9ac217b4c29128029f1abe805/slip19.html?t=1713115914521 8/8



slip20

April 14, 2024

[2]: # Write a Python program to plot 2D graph of the function f(x) = sin x and g(x)␣
↪= cos x in [−2￿,2￿]

import numpy as np
import matplotlib.pyplot as plt
# Define the functions
def f(x):

return np.sin(x)
def g(x):

return np.cos(x)

x = np.linspace(-2*np.pi , 2*np.pi , 100)
# Compute y values for f(x) and g(x)
y_f = f(x)
y_g = g(x)
# Create the plot
plt.plot(x, y_f, label='f(x) = sin(x)', linewidth=2, color='blue')
plt.plot(x, y_g, label='g(x) = cos(x)', linewidth=1, color='red')
# Add labels and legend
plt.xlabel('x')
plt.ylabel('y')
plt.legend()
plt.title('2Grap of f(x) = sin(x) and g(x)=cos(x)')
plt.show()

1



[7]: # Write a Python program to plot the 2D graph of the function f(x) = ex sin x␣
↪in [−5￿,5￿] with blue points line with upward pointing triangle

import numpy as np
import matplotlib.pyplot as plt

def f(x):
return np.exp(x) * np.sin(x)

x = np.linspace(-5*np.pi, 5*np.pi, 500)

y = f(x)

plt.plot(x, y, 'r^-', linewidth=1)
# Set x and y axis labels
plt.xlabel('x')
plt.ylabel('f(x)')
# Set the title of the graph
plt.title('2D Graph of f(x) = e^(x) * sin(x)')
# Show the graph

2



plt.show()

[8]: # Write a python program to reflect the line segment joining the points␣
↪A[−5,2],B[3,−4] through the line y = 2x −1

# Points A and B
A = (-5, 2)
B = (3, -4)

# Reflection line y = 2x - 1

# Calculating the slope of the reflection line
m = 2

# Calculating the perpendicular slope
m_perpendicular = -1/m
# Calculating the y-intercept of the reflection line
b = 2 * 0 - 1

# Function to find the reflection of a point through a line

3



def reflect_point(point):
x, y = point
x_reflect = (m * (y - b) + x) / (m**2 + 1)
y_reflect = m * x_reflect + b
return (x_reflect, y_reflect)

# Reflecting points A and B through the line
A_reflected = reflect_point(A)
B_reflected = reflect_point(B)

# Output
print("Reflection of point A:", A_reflected)
print("Reflection of point B:", B_reflected)

Reflection of point A: (0.2, -0.6)
Reflection of point B: (-0.6, -2.2)

[9]: # Write a Python program to plot the 3D graph of the function f(x,y) = sin␣
↪x+cos y, x,y ￿[−2￿,2￿] using wireframe plot.

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

x = np.linspace(-2 * np.pi, 2 * np.pi, 100)
y = np.linspace(-2 * np.pi, 2 * np.pi, 100)
# Create a meshgrid from x and y
X, Y = np.meshgrid(x, y)
# Calculate the Z values using the function f(x, y) = sin(x) + cos(y)
Z = np.sin(X) + np.cos(Y)
# Create a 3D plot
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
# Create a wireframe plot
ax.plot_wireframe(X, Y, Z)
# Set labels and title
ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('Z')
ax.set_title('3D Wireframe Plot of f(x, y) = sin(x) + cos(y)')
# Show the plot
plt.show()

4



[11]: # Write a Python program to solve the following LPP:
# Max Z = x + y
# subject to x −y ￿1
# x + y ￿2
# x ￿0,y ￿0

from pulp import *

problem= LpProblem("Maximize Z", LpMaximize)
x= LpVariable("x", lowBound=0, cat='Continuous')
y= LpVariable("y", lowBound=0, cat='Continuous')

Z = x + y
problem+= Z

problem+= x - y >= 1
problem+= x + y >= 2

problem.solve()

print("Status:", LpStatus[problem.status])
print("x =", value(x))

5



print("y =", value(y))
print("Optimal value of Z =",value(problem.objective))

Status: Unbounded
x = 0.0
y = 0.0
Optimal value of Z = 0.0

[12]: # Apply the following transformations on the point P[3,−2]
# I. Shearing in x direction by -2 units.
# II. Scaling in x and y direction by -3 and 2 units respectively.
# III. Reflection through x axis.
# IV. Reflection through the line y = −x.

import numpy as np

P=np.array([3,-2])
# I. Shearing in x direction by -2 units.
shearing_x = [P[0] + ((-2) * P[1]), P[1]]
# II. Scaling in x and y direction by -3 and 2 units respectively.
scaling_x = np.array([-3, 1]) * P
scaling_y = np.array([1, 2]) * P
# III. Reflection through x axis.
reflection_x_axis = np.array([1, -1]) * P
# IV. Reflection through the line y = −x.
reflection_line = np.array([-P[1],-P[0]])

print("Original point P:", P)
print("Shearing in X direction by -2 unit:", shearing_x)
print("Reflection through x-axis:", reflection_x_axis)
print("Scaling in X-coordinates by factor -3:", scaling_x)
print("Scaling in Y-coordinates by factor 2:", scaling_y)
print("Reflection through the line y = -x:", reflection_line)

Original point P: [ 3 -2]
Shearing in X direction by -2 unit: [7, -2]
Reflection through y-axis: [3 2]
Scaling in X-coordinates by factor -3: [-9 -2]
Scaling in Y-coordinates by factor 2: [ 3 -4]
Reflection through the line y = x: [ 2 -3]

6



slip21

April 14, 2024

[2]: # Write a Python program to plot 2D graph of the function f(x) = x4 in [0,5]␣
↪with red dashed line with circle markers

import numpy as np
import matplotlib.pyplot as plt

def f(x):
return x**4

x = np.linspace(0, 5, 100)
y = f(x)
# Plot the graph with red dashed line and circle markers
plt.plot(x, y, 'r--o')
plt.xlabel('x')
plt.ylabel('f(x)')
plt.title('Graph of f(x) = x**4')
plt.show()

1



[6]: # Write a Python program to plot the 3D graph of the function f(x) = ex2+y2
# for x,y ￿[0,2￿] using wireframe

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

x = np.linspace(0, 2 * np.pi, 100)
y = np.linspace(0, 2 * np.pi, 100)
# Create a meshgrid from x and y
X, Y = np.meshgrid(x, y)
# Calculate the Z values using the function f(x, y) = exp(x**2+y**2)
Z = np.exp( X**2 + Y**2 )
# Create a 3D plot
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
# Create a wireframe plot
ax.plot_wireframe(X, Y, Z,rstride=5,cstride=5)
# Set labels and title
ax.set_xlabel('X')

2



ax.set_ylabel('Y')
ax.set_zlabel('Z')
ax.set_title('3D Wireframe Plot of f(x, y) = exp(x**2+y**2)')
# Show the plot
plt.show()

[7]: # If the line segment joining the points A[2,5] and B[4,−13] is transformed to␣
↪the line segment A￿B￿ by the transformation matrix [T] =[2 3

# 4 1]
# then using python find the slope and midpoint of the transformed line

A = [2, 5]
B = [4, -13]

# Transformation matrix
T = [[2, 3],

[4, 1]]

# Function to multiply matrix and vector
def matrix_mult(matrix, vector):

result = [0, 0]
for i in range(len(matrix)):

3



for j in range(len(vector)):
result[i] += matrix[i][j] * vector[j]

return result

# Apply transformation matrix to points A and B
A_trans = matrix_mult(T, A)
B_trans= matrix_mult(T, B)

# Calculate slope
slope=(B_trans[1] - A_trans[1]) / (B_trans[0] - A_trans[0])
# Calculate midpoint
midpoint = [(A_trans[0] + B_trans[0]) / 2, (A_trans[1] + B_trans[1]) / 2]

print("Transformed point A':", A_trans)
print("Transformed point B':", B_trans)
print("Slope of transformed line segment:", slope)
print("Midpoint of transformed line segment:", midpoint)

Transformed point A': [19, 13]
Transformed point B': [-31, 3]
Slope of transformed line segment: 0.2
Midpoint of transformed line segment: [-6.0, 8.0]

[9]: # Write a python program to plot square with vertices at␣
↪[4,4],[2,4],[2,2],[4,2] and find its uniform expansion by factor 3, uniform␣
↪reduction by factor 0.4.

import numpy as np
import matplotlib.pyplot as plt

vertices = np.array([[4, 4], [2, 4], [2, 2], [4, 2], [4, 4]])

fig, ax = plt.subplots()
# Plot the original square
ax.plot(vertices[:, 0], vertices[:, 1], 'b-o', label='Original Square')
# Define the uniform expansion and reduction factors
expans_fac = 3
reduct_fac = 0.4
# Perform uniform expansion
expanded_ver= vertices * expans_fac
# Perform uniform reduction
reduced_ver= vertices * reduct_fac
# Plot the expanded and reduced squares
ax.plot(expanded_ver[:, 0],expanded_ver[:, 1], 'r-o',label='Uniform␣

↪Expansion')
ax.plot(reduced_ver[:, 0],reduced_ver[:, 1], 'g-o', label='Uniform Reduction')
# Set axis labels and title

4



ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_title('Uniform Expansion and Reduction of a Square')
ax.legend()
plt.grid()
# Set aspect ratio to 'equal' for a square plot
ax.set_aspect('equal')
plt.show()

[11]: # Write a Python program to solve the following LPP:
# Max Z = 2x + 4y
# subject to 2x + y ￿18
# 2x + 2y ￿30
# x + 2y = 26
# x ￿0,y ￿0
from pulp import *

problem= LpProblem("Maximize Z", LpMaximize)
x= LpVariable("x", lowBound=0, cat='Continuous')
y= LpVariable("y", lowBound=0, cat='Continuous')

5



Z = 2*x + 4*y
problem+= Z

problem+= 2*x + y <=18
problem+= 2*x + 2*y >=30
problem+= x + 2*y >= 26
problem+= x + 2*y <= 26

problem.solve()

print("Status:", LpStatus[problem.status])
print("x =", value(x))
print("y =", value(y))
print("Optimal value of Z =",value(problem.objective))

Status: Infeasible
x = 3.0
y = 12.0
Optimal value of Z = 54.0

[12]: # Apply the following transformations on the point P[−2,4].
# I. Shearing in Y direction by 7 units.
# II. Scaling in both X and Y direction by 4 and 7 units respectively.
# III. Rotation about origin by an angle 48 degrees.
# IV. Reflection through line y = x.

import numpy as np

P=np.array([-2,4])
# I. Shearing in Y direction by 7 units
shearing_y = [P[0], P[1] + (7 * P[0])]
# II. Scaling in both X and Y direction by 4 and 7 units respectively.
scaling_both = np.array([[4, 0],[0, 7]])
P_scaling_both = np.dot(scaling_both, P)
# III. Rotation about origin by an angle 48 degrees
angle = np.radians(48)
rotation_matrix = np.array([[np.cos(angle), -np.sin(angle)], [np.sin(angle), np.

↪cos(angle)]])
P_rotated = np.dot(rotation_matrix, P)
# IV. Reflection through line y = x.
reflection_line = np.array([P[1],P[0]])

print("Original point P:", P)
print("Shearing in Y direction:", shearing_y)
print("Scaling in both X and Y direction by 4 and 7 units:", P_scaling_both)
print("Rotation about origin by an angle 48 degrees:",P_rotated)

6



print("Reflection through the line y = x:", reflection_line)

Original point P: [-2 4]
Shearing in Y direction: [-2, -10]
Scaling in both X and Y direction by 4 and 7 units: [-8 28]
Rotation about origin by an angle 48 degrees: [-4.31084051 1.19023277]
Reflection through the line y = x: [ 4 -2]

7



slip22

April 14, 2024

[1]: # Write a python program to draw 2D plot y = log(x2) + sin(x) with suitable␣
↪label in the x axis , y

# axis and a title in [−5￿,5￿]

import numpy as np
import matplotlib.pyplot as plt
x = np.linspace(-5 * np.pi, 5 * np.pi, 500)
y = np.log(x**2) + np.sin(x)
plt.plot(x, y)
plt.xlabel('x-axis Label')
plt.ylabel('y-axis Label')
plt.title('2D Plot of y = log(x^2) + sin(x)')
plt.show()

1



[5]: # Write a python program to draw 2D plot y = xsin( 1 / x2) in [−5,5] with␣
↪suitable label in the x axis,y axis, a title and location of legend to lower␣
↪right corner

import numpy as np
import matplotlib.pyplot as plt

x = np.linspace(-5, 5, 500)
y = x * np.sin(1 / x**2)
plt.plot(x, y)
plt.xlabel('x')
plt.ylabel('y')
plt.title('2D Plot of y = x * sin(1/x^2)')
plt.show()

[6]: # Write a python program to find the angle at each vertices of the triangle ABC␣
↪where A[0,0],B[2,2] and C[0,2].

2



import numpy as np

A = np.array([0, 0])
B = np.array([2, 2])
C = np.array([0, 2])
AB = np.linalg.norm(B - A)
BC = np.linalg.norm(C - B)
AC = np.linalg.norm(C - A)

angle_A = np.arccos((AB**2 + AC**2 - BC**2) / (2 * AB * AC))
angle_B = np.arccos((-AB**2 + AC**2 + BC**2) / (2 * AC * BC))
angle_C = np.pi - angle_A - angle_B

angle_A_deg = np.degrees(angle_A)
angle_B_deg = np.degrees(angle_B)
angle_C_deg = np.degrees(angle_C)

print("Angle at vertex A: {:.2f} degrees".format(angle_A_deg))
print("Angle at vertex B: {:.2f} degrees".format(angle_B_deg))
print("Angle at vertex C: {:.2f} degrees".format(angle_C_deg))

Angle at vertex A: 45.00 degrees
Angle at vertex B: 90.00 degrees
Angle at vertex C: 45.00 degrees

[7]: # Write a Python program to find area and perimeter of the triangle ABC where␣
↪A[0,0],B[5,0],C[3,3].

import numpy as np
A = np.array([0, 0])
B = np.array([5, 0])
C = np.array([3, 3])

AB = np.linalg.norm(B - A)
BC = np.linalg.norm(C - B)
CA = np.linalg.norm(A - C)

s = (AB + BC + CA) / 2
area = np.sqrt(s * (s - AB) * (s - BC) * (s - CA))
perimeter = AB + BC + CA

print("Triangle ABC:")
print("Side AB:", AB)
print("Side BC:", BC)
print("Side CA:", CA)
print("Area:", area)

3



print("Perimeter:", perimeter)

Triangle ABC:
Side AB: 5.0
Side BC: 3.605551275463989
Side CA: 4.242640687119285
Area: 7.5000000000000036
Perimeter: 12.848191962583275

[10]: # Write a Python program to solve the following LPP:
# Min Z = x + y
# subject to x + y ￿11
# x ￿6
# y ￿6
# x ￿0,y ￿0.

from pulp import *

problem= LpProblem("Minimize Z", LpMinimize)
x= LpVariable("x", lowBound=0, cat='Continuous')
y= LpVariable("y", lowBound=0, cat='Continuous')

Z = x + y
problem+= Z

problem+= x + y <=11
problem+= x >= 6
problem+= y >= 6

problem.solve()
print("Status:", LpStatus[problem.status])
print("x =", value(x))
print("y =", value(y))
print("Optimal value of Z =",value(problem.objective))

Status: Infeasible
x = 6.0
y = 6.0
Optimal value of Z = 12.0

[1]: # Write the Python program for each of the following.
# I. Rotate the point (1,1) about (1,4) through angle ￿/2.
# II. Find Distance Between two points (0,0) and (1,0)
# III. Find the shearing of the point (3,4) in X direction by 3 units.
# IV. Represent two dimensional points using point function (−2,5)
import math

4



def rotate_point(x, y, cx, cy, theta):
x_new = cx + (x - cx) * math.cos(theta) - (y - cy) * math.sin(theta)
y_new = cy + (x - cx) * math.sin(theta) + (y - cy) * math.cos(theta)
return x_new, y_new

def distance_between_points(x1, y1, x2, y2):
return math.sqrt((x2 - x1)**2 + (y2 - y1)**2)

def shear_point_x(x, y, shear_factor):
x_new = x + shear_factor * y
y_new = y
return x_new, y_new

def create_point(x, y):
return x, y

# Task I: Rotate the point (1,1) about (1,4) through angle ￿/2
rotated_point = rotate_point(1, 1, 1, 4, math.pi/2)
print("Rotated point:", rotated_point)

# Task II: Find distance between two points (0,0) and (1,0)
distance = distance_between_points(0, 0, 1, 0)
print("Distance between points:", distance)

# Task III: Find the shearing of the point (3,4) in X direction by 3 units
sheared_point = shear_point_x(3, 4, 3)
print("Sheared point:", sheared_point)

# Task IV: Represent two-dimensional points using point function (-2,5)
point = create_point(-2, 5)
print("2D point:", point)

Rotated point: (4.0, 4.0)
Distance between points: 1.0
Sheared point: (15, 4)
2D point: (-2, 5)

5



slip23

April 14, 2024

[1]: # Write a python program plot the graphs of sin x,and cos x in [0,￿] in one␣
↪figure with 2 ×1 subplots

import numpy as np
import matplotlib.pyplot as plt

# Generate x values from 0 to ￿
x = np.linspace(0, np.pi, 100)

# Calculate y values for sin(x) and cos(x)
y_sin = np.sin(x)
y_cos = np.cos(x)

# Create subplots
fig, (ax1, ax2) = plt.subplots(2, 1)

# Plot sin(x)
ax1.plot(x, y_sin, label='sin(x)', color='blue')
ax1.set_title('sin(x)')
ax1.set_xlabel('x')
ax1.set_ylabel('sin(x)')
ax1.legend()

# Plot cos(x)
ax2.plot(x, y_cos, label='cos(x)', color='red')
ax2.set_title('cos(x)')
ax2.set_xlabel('x')
ax2.set_ylabel('cos(x)')
ax2.legend()

# Adjust layout to prevent overlap
plt.tight_layout()

# Show plot
plt.show()

1



[2]: # Write a python program to Plot the graph of the following functions in the␣
↪given interval.

# i. f(x) = x3 in [0,5].
# ii. f(x) = x2 in [−2,2]

import numpy as np
import matplotlib.pyplot as plt
# Define the functions

def f1(x):
return x**3

def f2(x):
return x**2

x1 = np.linspace(0, 5, 100)
x2 = np.linspace(-2, 2, 100)
# Calculate y values for the functions
y1 = f1(x1)
y2 = f2(x2)
# Create a figure with two subplots side by side
fig, axs = plt.subplots(1, 2, figsize=(10, 5))

2



# Plot f(x) = x^3 in the first subplot
axs[0].plot(x1, y1, label='f(x) = x^3')
axs[0].set_xlabel('x')
axs[0].set_ylabel('f(x)')
axs[0].set_title('f(x) = x^3 in [0, 5]')
axs[0].legend()
# Plot f(x) = x^2 in the second subplot
axs[1].plot(x2, y2, label='f(x) = x^2')
axs[1].set_xlabel('x')
axs[1].set_ylabel('f(x)')
axs[1].set_title('f(x) = x^2 in [-2, 2]')
axs[1].legend()
# Add overall title to the figure
fig.suptitle('Graphs of f(x) = x^3 and f(x) = x^2')
# Adjust spacing between subplots
plt.tight_layout()
# Show the plot
plt.show()

[3]: # Write a Python program to draw regular polygon with 20 sides and radius 1␣
↪centered at (0,0)

import numpy as np
import matplotlib.pyplot as plt
# Number of sides of the polygon
n = 20
# Radius of the polygon
radius = 1

3



# Generate angles for the vertices of the polygon
angles = np.linspace(0, 2 * np.pi, n + 1)[:-1]
# Calculate x and y coordinates for the vertices of the polygon
x = radius * np.cos(angles)
y = radius * np.sin(angles)
# Create a figure
fig, ax = plt.subplots()
# Plot the regular polygon
ax.plot(x, y, 'b-o', linewidth=2, markersize=8)
ax.set_aspect('equal', 'box')
ax.set_title(f'Regular Polygon with {n} sides')
ax.set_xlabel('x')
ax.set_ylabel('y')
# Show the plot
plt.show()

[6]: # Write a Python program to find area and perimeter of triangle ABC where␣
↪A[0,1],B[−5,0] and C[−3,3].

import math
import numpy as np

4



A = np.array([0, 1])
B = np.array([-5, 0])
C = np.array([-3, 3])

AB = np.linalg.norm(B - A)
BC = np.linalg.norm(C - B)
CA = np.linalg.norm(A - C)

s = (AB + BC + CA) / 2
area = np.sqrt(s * (s - AB) * (s - BC) * (s - CA))
perimeter = AB + BC + CA

print("Triangle ABC:")
print("Side AB:", AB)
print("Side BC:", BC)
print("Side CA:", CA)
print("Area:", area)
print("Perimeter:", perimeter)

Triangle ABC:
Side AB: 5.0990195135927845
Side BC: 3.605551275463989
Side CA: 3.605551275463989
Area: 6.500000000000002
Perimeter: 12.310122064520764

[8]: # Write a Python program to solve the following LPP:
# Max Z = 3x + 5y + 4z
# subject to 2x + 3y ￿8
# 2x + 5y ￿10
# 3x + 2y + 4z ￿15
# x,y,z ￿0.

from pulp import *
# Create the LP prob
prob = LpProblem("Minimize Z", LpMaximize)
# Define the decision variables
x = LpVariable('x', lowBound=0, cat='Continuous')
y = LpVariable('y', lowBound=0, cat='Continuous')
z = LpVariable('z', lowBound=0, cat='Continuous')

# Set the objective function
Z= 3*x + 5*y + 4*z
prob += Z
# Add the constraints
prob += 2*x + 3*y <= 8

5



prob += 2*y + 5*z <= 10
prob += 3*x + 2*y + 4*z <= 15
# Solve the LP prob
prob.solve()
# Print the status of the LP prob
print("Status: ", LpStatus[prob.status])
# Print the optimal values of the decision variables
print("Optimal Values:")
print("x = ", x.varValue)
print("y = ", y.varValue)
print("z = ", z.varValue)
# Print the optimal value of the objective function
print("Optimal Objective Function Value = ", value(prob.objective))

Status: Optimal
Optimal Values:
x = 2.1707317
y = 1.2195122
z = 1.5121951
Optimal Objective Function Value = 18.658536500000004

[11]: # Write the Python program to apply each of the following transformation on the␣
↪point P =

# [3,−1].
# I. Reflection through X axis.
# II. Rotation about origin by an angle 30 degrees.
# III. Scaling in Y coordinate by factor 8.
# IV. Shearing in X direction by 2 units

import numpy as np
P=np.array([3,-1])
# I. Reflection through X axis.
reflection_x_axis = np.array([1, -1]) * P
# II. Rotation about origin by an angle 30 degrees.
rotation_matrix = np.array([[np.cos(np.pi/6), -np.sin(np.pi/6)],

[np.sin(np.pi/6), np.cos(np.pi/6)]])
P_rotation = np.dot(rotation_matrix, P)
# III. Scaling in Y coordinate by factor 8
scaling_y = np.array([1, 8]) * P
# IV. Shearing in X direction by 2 units
shearing_x = [P[0] + (2 * P[1]), P[1]]
print("Original point P:", P)
print("Reflection through x-axis:", reflection_x_axis)
print("Rotation about origin through an angle of 30 degree:",P_rotation)
print("Scaling in Y-coordinates by factor 8:", scaling_y)
print("Shearing in X direction:", shearing_x)

6



Original point P: [ 3 -1]
Reflection through y-axis: [3 1]
Rotation about origin through an angle of 30 degree: [3.09807621 0.6339746 ]
Scaling in Y-coordinates by factor 8: [ 3 -8]
Shearing in X direction: [1, -1]

7



slip24

April 14, 2024

[1]: # write the Python program to plot the graph of the function, using def()
#
#f(x) = x2 + 4 if −10 ￿x < 5
# 3x + 9 if 5 ￿x < 10

import numpy as np
import matplotlib.pyplot as plt

def f(x):
if -10 < x < 5:

return x**2 + 4
elif 5 <= x:

return 3*x + 9
else:

return None
# Generate x values
# Generate 500 points between -11 and 11
x = np.linspace(-11, 11, 500)
# Calculate y values using f(x)
y = np.array([f(xi) for xi in x])
# Create the plot
plt.plot(x, y, label='f(x)')
plt.xlabel('x')
plt.ylabel('f(x)')
plt.title('Graph of f(x)')
plt.legend()
plt.grid(True)
plt.show()

1



[4]: # Write a Python program to plot graph of the function f(x) = log(3x2), in␣
↪[1,10] with black dashed points.

import numpy as np
import matplotlib.pyplot as plt

def f(x):
return np.log(3 * x**2)

x = np.linspace(1, 10, 100)
y = f(x)
# Create a plot
plt.plot(x, y, 'k--', marker='o', markersize=6)
plt.xlabel('X')
plt.ylabel('f(x)')
plt.title('Plot of f(x) = log(3x^2)')
plt.show()

2



[5]: # Write a Python program to generate vector x in the interval [−22,22] using␣
↪numpy package with 80 subintervals

import numpy as np

start = -22
end = 22
num_subintervals = 80

x = np.linspace(start, end ,num = num_subintervals+1)
# Print the generated vector x
print(x)

[-22. -21.45 -20.9 -20.35 -19.8 -19.25 -18.7 -18.15 -17.6 -17.05
-16.5 -15.95 -15.4 -14.85 -14.3 -13.75 -13.2 -12.65 -12.1 -11.55
-11. -10.45 -9.9 -9.35 -8.8 -8.25 -7.7 -7.15 -6.6 -6.05
-5.5 -4.95 -4.4 -3.85 -3.3 -2.75 -2.2 -1.65 -1.1 -0.55
0. 0.55 1.1 1.65 2.2 2.75 3.3 3.85 4.4 4.95
5.5 6.05 6.6 7.15 7.7 8.25 8.8 9.35 9.9 10.45
11. 11.55 12.1 12.65 13.2 13.75 14.3 14.85 15.4 15.95

3



16.5 17.05 17.6 18.15 18.7 19.25 19.8 20.35 20.9 21.45
22. ]

[6]: # Write a python program to plot triangle with vertices [3,3],[5,6],[5,2], and␣
↪its rotation about the origin by angle −￿ radians

import numpy as np
import matplotlib.pyplot as plt

v1 = np.array([3, 3])
v2 = np.array([5, 6])
v3 = np.array([5, 2])

theta = -np.pi
R = np.array([[np.cos(theta), -np.sin(theta)], [np.sin(theta), np.cos(theta)]])

v1_rotated = np.dot(R, v1)
v2_rotated = np.dot(R, v2)
v3_rotated = np.dot(R, v3)

plt.figure()

plt.plot([v1[0], v2[0], v3[0], v1[0]], [v1[1], v2[1], v3[1], v1[1]], 'b-',␣
↪label='Original Triangle')

plt.
↪plot([v1_rotated[0],v2_rotated[0],v3_rotated[0],v1_rotated[0]],[v1_rotated[1],␣
↪v2_rotated[1], v3_rotated[1], v1_rotated[1]], 'r-', label='Rotated␣
↪Triangle')

plt.plot(0, 0, 'ko', label='Origin')
plt.xlabel('X')
plt.ylabel('Y')
plt.title('Triangle Rotation')
plt.legend()
# Show the plot
plt.show()

4



[8]: # Write a Python program to solve the following LPP:
# Min Z = 3.5x + 2y
# subject to x + y ￿5
# x ￿4
# y ￿2
# x ￿0,y ￿0

from pulp import *

problem= LpProblem("Minimize Z", LpMinimize)
x= LpVariable("x", lowBound=0, cat='Continuous')
y= LpVariable("y", lowBound=0, cat='Continuous')

Z = 3.5 * x + 2 * y
problem+= Z

problem+= x + y >= 5
problem+= x >= 4
problem+= y <= 2

5



problem.solve()

print("Status:", LpStatus[problem.status])
print("x =", value(x))
print("y =", value(y))
print("Optimal value of Z =",value(problem.objective))

Status: Optimal
x = 4.0
y = 1.0
Optimal value of Z = 16.0

[9]: # Apply Python program in each of the following transformations on the point␣
↪P[3,−1]

# I. Refection through X−axis.
# II. Scaling in X−coordinate by factor 2.
# III. Scaling in Y−coordinate by factor 1.5.
# IV. Reflection through the line y = x.
import numpy as np
P=np.array([3,-1])
# I. Refection through X−axis.
reflection_x_axis = np.array([1, -1]) * P
# II. Scaling in X−coordinate by factor 2.
scaling_x = np.array([2, 1]) * P
# III. Scaling in Y−coordinate by factor 1.5.
scaling_y = np.array([1, 1.5]) * P
# IV. Reflection through the line y = x.
reflection_line = np.array([P[1],P[0]])

print("Original point P:", P)
print("Reflection through x-axis:", reflection_x_axis)
print("Scaling in X-coordinates by factor 2:", scaling_x)
print("Scaling in Y-coordinates by factor 1.5:", scaling_y)
print("Reflection through the line y = x:", reflection_line)

Original point P: [ 3 -1]
Reflection through y-axis: [3 1]
Scaling in X-coordinates by factor 2: [ 6 -1]
Scaling in Y-coordinates by factor 1.5: [ 3. -1.5]
Reflection through the line y = x: [-1 3]

6



slip25

April 14, 2024

[1]: # Using Python plot the surface plot of function z = cos (x2 + y2 −0.5)in the␣
↪interval from −1 < x,y < 1.

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

def func(x, y):
return np.cos(x**2 + y**2 - 0.5)

# Generate x, y values in the interval from -1 to 1
x = np.linspace(-1, 1, 100)
y = np.linspace(-1, 1, 100)
X, Y = np.meshgrid(x, y) # Create a grid of x, y values
Z = func(X, Y) # Compute z values using the function
# Create a 3D plot
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
ax.plot_surface(X, Y, Z, cmap='viridis') # Plot the surface
ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('Z')
ax.set_title('Surface Plot of z = cos(x**2 + y**2 - 0.5)')
plt.show()

1



[4]: # Using Python plot the graph of function f(x) = sin−1(x) on the interval [−1,1]

import numpy as np
import matplotlib.pyplot as plt

x = np.linspace(-1, 1, 1000)
# Calculate f(x) values
f_x = np.arcsin(x)
# Create the plot
plt.plot(x, f_x)
plt.xlabel('x')
plt.ylabel('f(x)')
plt.title('Plot of f(x) = sin^-1(x)')
plt.grid(True)
plt.axhline(0, color='black') # Add horizontal grid line at y=0
plt.show()

2



[5]: # Rotate the line segment by 180◦ having end points (1,0) and (2,−1)

import numpy as np
# Define the endpoints of the line segment
point1 = np.array([1, 0])
point2 = np.array([2, -1])
# Define the rotation matrix for 180 degrees
R = np.array([[-1, 0],[0, -1]])
# Rotate the endpoints of the line segment
rotated_point1 = np.dot(R, point1)
rotated_point2 = np.dot(R, point2)
print("Rotated endpoint 1: ", rotated_point1)
print("Rotated endpoint 2: ", rotated_point2)

Rotated endpoint 1: [-1 0]
Rotated endpoint 2: [-2 1]

[6]: # Using sympy, declare the points P(5,2),Q(5,−2),R(5,0), check whether these␣
↪points are collinear.

3



# Declare the ray passing through the points P and Q, find the length of this␣
↪ray between P and Q.

# Also find slope of this ray

from sympy import Point, Line

P = Point(5, 2)
Q = Point(5, -2)
R = Point(5, 0)
# Check if points P, Q, and R are collinear
line_PQ = Line(P, Q)
line_PR = Line(P, R)
collinear = line_PQ.is_parallel(line_PR)
# Print the result
if collinear:

print("Points P, Q, and R are collinear")
else:

print("Points P, Q, and R are not collinear")
# Calculate the length of the ray PQ
length_PQ = P.distance(Q)
# Calculate the slope of the ray PQ
slope_PQ = (Q.y - P.y) / (Q.x - P.x)
# Print the length and slope of the ray PQ
print("Length of the ray PQ:", length_PQ)
print("Slope of the ray PQ:", slope_PQ)

Points P, Q, and R are collinear
Length of the ray PQ: 4
Slope of the ray PQ: zoo

[7]: # Write a Python program to solve the following LPP:
# Max Z = 150x + 75y
# subject to 4x + 6y ￿24
# 5x + 3y ￿15
# x ￿0,y ￿0

from pulp import *
# Create the LP problem as a maximization problem
problem = LpProblem("LPP", LpMaximize)
# Define the decision variables
x = LpVariable('x', lowBound=0, cat='Continuous')
y = LpVariable('y', lowBound=0, cat='Continuous')
# Define the objective function
Z= 150*x + 75*y
problem += Z
# Define the constraints
problem += 4*x + 6*y <=24

4



problem += 5*x + 3*y <=15
# Solve the LP problem
problem.solve()
# Print the status of the solution
print("Status:", LpStatus[problem.status])
# Print the optimal values of x and y
print("Optimal x =", value(x))
print("Optimal y =", value(y))
# Print the optimal value of the objective function
print("Optimal Z =", value(problem.objective))

Status: Optimal
Optimal x = 3.0
Optimal y = 0.0
Optimal Z = 450.0

[8]: # Write a python program to apply the following transformations on the point␣
↪(−2,4) :

# (I) Refection through X−axis.
# (II) Scaling in X−coordinate by factor 6.
# (III) Shearing in X direction by 4 units.
# (IV) Rotate about origin through an angle 30◦.

import numpy as np
P=np.array([-2,4])

# (I) Refection through X−axis.
reflection_x_axis = np.array([1, -1]) * P
# (II) Scaling in X−coordinate by factor 6.
scaling_x = np.array([6, 1]) * P
# (III) Shearing in X direction by 4 units.
shearing_x = [P[0] + (4 * P[1]), P[1]]
# (IV) Rotate about origin through an angle 30◦.
rotation_matrix = np.array([[np.cos(np.pi/6), -np.sin(np.pi/6)],

[np.sin(np.pi/6), np.cos(np.pi/6)]])
P_rotation = np.dot(rotation_matrix, P)

print("Original point P:", P)
print("Reflection through x-axis:", reflection_x_axis)
print("Scaling in X-coordinates by factor 6:", scaling_x)
print("Shearing in X direction:", shearing_x)
print("Rotation about origin through an angle of 30 degree:",P_rotation)

Original point P: [-2 4]
Reflection through x-axis: [-2 -4]
Scaling in X-coordinates by factor 6: [-12 4]
Shearing in X direction: [14, 4]

5



Rotation about origin through an angle of 30 degree: [-3.73205081 2.46410162]

6